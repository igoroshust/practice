#### Константный, или постоянный по времени, алгоритм O(1)
Константным, или постоянным по времени, называется алгоритм, который выполняет необходимое действие всегда за одинаковое
количество времени (с точностью до небольшого множителя, вызванного техническими характеристиками вычислительной машины).

К таким алгоритмам относят очень простые операции:
- Присваивание;
- Арифметические операции;
- Логические операции;
- Сравнение объектов;
- Другие действия.

#### Линейный алгоритм (O(n))
Более сложные алгоритмы уже могут зависеть от количества входных данных. Например, если вам нужно найти максимальный
элемент в списке, то самый простой способ - пройтись по всем элементам списка. Здесь контстантного времени уже не хватит,
потому что велика разница между поиском максимального среди 3 элементов или среди 3 миллионов элементов.

Однако больше ни от чего такой поиск не зависит - чем больше элементов, тем больше времени нужно, и количество времени
возрастает в тоже самое количество раз, как и размер списка. Такие алгоритмы называют линейными.
Например, пространственная сложность приготовления ужина зависит от количества гостей на нём. Чем больше гостей, тем больше
тарелок придётся мыть после них. 


#### Логарифмический алгоритм (O(log n))
Логарифмическая сложность - когда на каждом шаге размер проблемы уменьшается вдвое (или в k раз). Это очень эффективно:
для n = 1000000 шагов всего ~20 (поскольку 2^20 = 1000000).
Бывают ситуации, когда алгоритмы могут работать быстрее, чем линейные: самые распространённые - логарифмические алгоритмы.
Их название напрямую связано с тем, как возрастает временная сложность алгоритма с ростом размера входных данных.
Например, если нужно разрезать лист А4 на 16 частей. Если разрезать пополам, потом сложить их и разрезать сразу оба, а
получившиесся четверти снова сложить и снова разрезать, но уже сразу 4 штуки и т.д. - это и есть логарифмический алгоритм.



#### Квадратичный алгоритм (O(n^2))
Квадратичный алгоритм - время выполнения алгоритма растёт пропорционально квадрату размера входных данных.
Такие алгоритмы просты в реализации, но их применяют только для небольших данных или как часть более сложных структур.
Пример: простые сортировки (пузырьковая, вставками), поиск дубликатов в списке без оптимизаций.


#### Полиномиальные алгоритмы (O(n^k))
Естественно, бывают алгоритмы и сложнее. Линейный алгоритм является частным случаем полиномиальных алгоритмов, а всех их
объединяет, что для обработки n объектов входных данных (чисел, например) требуется n^k операций.

Конкретно: чтобы расставить книги в алфавитном порядке, нам понадобится примерно n^2 операций (квадратичный алгоритм O(n^2))
Почему n^2? Рассмотрим на примере расстановки 10 книг в алфавитном порядке (слева направо):

1) Сначала мы должны найти самую первую книгу: просматриваем одну за одной, чтобы найти, какая должна стоять первой.
Выбираем любую из 10 и сравниваем с каждой, чтобы убедиться, что она должна быть первой, или установить, что сравниваемая
книга должна стоять левее. Всего проводим 9 сравнений. Ставим её на полку.

2) Берём произвольно следующую книгу (вторую) из оставшихся 9. Для неё проводим аналогичную операцию - сравниваем с
оставшимися 8. Таким боразом имеет ещё 8 сравнений.

3) Берём N-ную книгу из 10. Предполагается, что к этому моменту мы уже поставили на полку N-1 книгу. Для сравнения с N-ой
у нас останется 10-N книг. А значит, столько же сравнений.

4) И, наконец, когда остаётся только 2 книги - нам нужно сделать только одно сравнение.

5) И для последней книги мы не должны ничего сравнивать, поэтому просто ставим на полку - имеем 0 сравнений. После этого
завершаем работу "алгоритма"

Проведём расчёты общего количества сравнений. Имеется N операций взятия книги и сравнения с оставшимися. В нашем примере -
это десять - столько раз мы берём произвольную книгу из "кучи" и сравниваем с нераставленными.
Сложим все сравнения, которые мы делали все эти 10 раз:
`9 + 8 + 7 + 6 + 5 + 4 + 3 + 2 + 1 + 0`

В математике такая последовательность чисел называется арифметической прогрессией (каждый последующий член последовательности
отличается от предыдущего на постоянное число). Существует формула для нахождения суммы членов арифметической прогрессии:
мы должны найти среднее арифметическое первого и последнего членов прогрессии и умножить на количество всех членов.

Для нашей арифметической прогрессии имеем:
`(9 + 0)/2 * 10 = 45`. 45 - общее количество операций сравнения, которые мы должны сделать, чтобы расставить книги в про
извольном порядке. А что, если у нас не 10 книг, а какое-то очень большое N? Попробуем обобщить эту формулу.
Здесь 9 - это общее количество книг в "куче" минус единица (потому что нам не нужно сравнивать книгу с самой собой).
Для произвольно большого количества книг это число будет равно N-1. Найденное среднее арифметическое мы должны умножить
на количество книг в куче согласно формуле: `(N-1 + 0)/2 * N`, затем приводим формулу к виду: `0.5N^2 - 0.5N`.

Вспомним, что мы искали что-то похожее на n^2, и мы нашли! Конечно, здесь есть множитель перед квадратом N да ещё и дополнительное
слагаемое. Стоит сказать, что n^2 - только оценка сложности. Для анализа алгоритмов нам, как правило, не нужно знать точный
множитель, а находить только общую зависимость от входных данных.


#### Оценка сложности алгоритма (3 величины)
- "O" большая - верхняя оценка сложности алгоритма. Оценка работы алгоритма в худшем случае (хуже не будет).

- "Ω" (омега) - нижняя оценка сложности. Оценка работы алгоритма в лучшем случае.

- "Θ" (тета) - точная оценка сложности. Точная оценка работы алгоритма.

#### Асимптотическая сложность
При помощи символа "O" можно записывать так называемую асимптотическую сложность алгоритма. Это удобная краткая запись
оценки "проблемности" алгоритма.

| Сложность алгоритма | О-нотация |                                                     Примеры |
|:--------------------|:---------:|------------------------------------------------------------:|
| Константная         |   O(1)    |                                      Сложение, присваивание |
| Линейная            |   O(n)    |                      Поиск максимального элемента из списка |
| Логарифмическая     | O(log(n)) |                                  Разрезание бумаги на части |
| Квадратичная        |  O(n^2)   | Расстановка книг в алфавитном порядке, сортировка пузырьком |
| Полиномиальная      |  O(n^k)   |                           Наивное умножение матриц (O(n^3)) |
| Факториальная       |   O(n!)   |                  Перебор всех возможных перестановок (ужас) |


#### Для чего необходимы сложности
Для ответа на этот вопрос необходимо рассмотреть работы алгоритмов (в условных единицах) различной сложности с некоторыми
примерами размеров данных.

| Сложность/размер входных данных | n = 5       | n = 10      |                  n = 20 |                               n = 30 |
|:--------------------------------|:---------:|-------------:|------------------------:|-------------------------------------:|
| O(1)                            |1|1|                       1 |                                    1 |
| O(log(n))                       |2|3|                       4 |                                    4 |
| O(n)                            |5|10|                      20 |                                   30 |
| O(n^2)                          |25|100|                     400 |                                  900 |
| O(n!)                           |120|3628800|              243290200 8176640000 |  2652528598 1219106821 7601719009280 |


#### Логарифм
Логарифм - это степень, в которую нужно возвести основание, чтобы получить заданное число. Для вычисления нужны 2 параметра:
- Основание логарифма
- Число, для которого вычисляется логарифм

Примеры:
- log2(8) = 3, так как 2^3 = 8
- log9(81) = 2, так как 9^2 = 81

O(log2(5)) = 2
O(log2(10)) = 3
O(log2(20)) = 4
O(log2(30)) = 4


## Структуры данных
Структура данных - программная единица, позволяющая хранить и обрабатывать множество логически связанных объектов.

Используя различным комбинации примитивов (объектов базовых типов), можно конструировать объекты, имеющие в свою очередь
внутреннюю структуру: списки, словари и даже экземпляры классов. Всё это и не только понимается под "структурами данных".

Каждую структуру данных мы рассматриваем с точки зрения её хранения в памяти, и, в зависимости от этого, как реализуются
основные функции работы с ними:
- доступ к элементу по индексу;
- вставка элемента;
- удаление элемента;
- получение размера структуры.

#### Массивы
Массив - упорядоченный набор данных. "Упорядоченный" - значит, что хранение этой структуры в памяти каким-то образом организовано.
Массивы бывают: одномерные, двумерные, трёхмерные и т.д.

Их отличительной особенностью является хранение элементов в последовательных ячейках памяти. Это становится одним из ограничений
массива: при его создании мы всегда должны указывать, какое количество физической памяти нужно для него "забронировать".
```python
2[]
27
271[]
2713
27138[][][]
271384[][][]
#  просто цифры - local size - фактическая заполненность массива;
#  цифры + ячейки - capacity - зарезервированный размер памяти (capacity) - вместимость памяти для этого массива.
```

Статические массивы - те, для которых заранее резервируется фиксированная область памяти.
Динамические массивы - те, которые могут изменять свой размер с помощью буферного механизма.

Наиболее выгодное использование массивов возникает в ситуациях, когда происходит частое обращение к элементам массива по
индексам, и в меньшей степени возникает необходимость добавлять или удалять элементы на произвольное место.

Массивы можно сравнить со списком легкоатлетов, добижавших до финиша. Мы всегда знаем их общее количество.
По таблице результатов (индексы) можно найти спортсмена по позиции. Во время забега спортсмены приходят к финишной черте
один за другим, пополняя массив с конца (это просто, [O(1)]). Но если исключить 1 спортсмена из таблица, то придётся
каждого двигать на 1 строчку вверх, и сделать это уже тяжелее [O(n)]. Ведь, если дисквалифицировать победителя, то придётся
абсолютно каждого так сдвигать, что требует множество операций [O(n)].

|                    Операция                     |                                  Сложность |
|:-----------------------------------------------:|-------------------------------------------:|
|                Получение размера                |                                       О(1) |
|     Получение элементов массива по индексу      |                                       O(1) |
|        Вставка/Удаление элемента в конец        |                                       O(1) |
| Вставка/Удаление элемента на произвольное место |                                       O(n) |
| Расширение памяти при выходе за пределы массива |                                       O(n) |

Разработчики Python, предпочитая удобство и эффективность, внедряют в язык структуры не совсем так строго, как они описаны
в теории. В связи с этим объект типа список (list) является динамическим массивов (способен изменять свой размер 
с помощью буферного механизма)


**Дополнительно про массивы**
В переменной содержится ссылка (указатель) на ячейку памяти, в которой хранится первый элемент и физический размер массива
(capacity). Благодаря ссылке можно выяснить точное положение этого объекта в памяти, а также количество байт, необходимое
для его хранения.

В связи с тем, что элементы хранятся в последовательных ячейках памяти, между индексом произвольного элемента относительо 
первого элемента существует однозначная линейная связь, то есть можно найти указатель на произвольный объект в памяти
через указатель на первый элемент, используя только операции сложения и умножения на число. Рассмотрим этот принцип на
абстрактном примере:
- Пусть М - указатель на ячейку в памяти, в которой хранится первый элемент;
- F - размер ячейки памяти (в байтах) для одного элемента;
- N - входной элемент;
- i - индекс.
Тогда для элемента N с индексом i (отсчёт начинается с нуля) будем иметь указатель на ячейку произвольную N ячейку в памяти.
`N = M + F * i`

Может быть удивительно, но мы можем складывать указатель и размер ячейки памяти. Это объясняется операцией на уровне железа.
Указатель - это число (как правило, в шестнадцатеричном представлении, например, 0xF510), указывающее порядковый номер байта
в памяти, где хранится элемент, а размер ячейки в памяти также представлен в байтах. Положение байта первого элемента "сдвигаем"
на индекс i, умноженный на размер ячейки.

Как видно, используя лишь арифметические операции мы смогли получить указатель на искомую ячейку памяти.
C точки зрения алгоритмической сложности мы можем это сделать за константное время - O(1), ведь нам не требовалось проделывать
много операций для нахождения этого указателя - всего лишь две арифметические операции. И более того, количество этих операций
никак не зависит от количества элементов в массиве. Аналогично и с размером массива - его можно получить за константное время, 
ведь оно уже хранится в переменной этой структуры данных.

Однако всё становится интереснее, если требуется добавлять или удалять элементы из динамического массива. Рассмотрим несколько
возможных ситуаций.

1) Вставка элемента в конец массива, не выходя за его пределы. Если мы вставляем элемент и его текущая длина меньше, чем
физический размер памяти, то мы просто заполняем выделенную ячейку памяти и делаем это за константное время. Можно представить
себе это как книжную полку, в которую мы просто справа доставляем книги, пока хватает пространства.

2) Если мы хотим поставить книгку на полку, но места уже на ней нет, а необходимо разместить все книги по тематике на одной
полке, то в жизни мы бы переместили все книги на полку побольше. Тоже самое происходит, если мы пытаемся вставить элемент
в конец массива, выходя за пределы выделенной памяти. В памяти происходит тоже самое - все ячейки массива перемещаются в 
область памяти, которая заведомо больше исходной (например, в два раза). И для этого нам нужно извлечь каждый элемент и
переместить его в памяти, что потребует нескольких действий для каждого элемента. Сложность такого процесса будет - O(n),
где n - количество элементов в массиве.

3) Если мы захотим удалить элемент из конца, то это будет за константное время (как и в первом случае). А вот если мы захотим
удалить элемент из начала, то нам придётся передвигать все элементы на 1 вправо, что потребует O(n) действий в худшем случае.

4) Аналогично, если нужно вставить элемент не в конец, а в начало или середину - нам придётся "сдвинуть" все элементы вправо,
а на освободившеемся место вставить новый элемент. И это также потребует O(n).

**Дополнительно:**
[Статья про эксперименты с массивами](https://lms-cdn.skillfactory.ru/assets/courseware/v1/ccb347419a62fdba19bfc1b0d7f00c36/asset-v1:SkillFactory+FPW-2.0_D+2022+type@asset+block/%D0%94%D0%BE%D0%BF._%D0%BC%D0%B0%D1%82%D0%B5%D1%80%D0%B8%D0%B0%D0%BB._%D0%AD%D0%BA%D1%81%D0%BF%D0%B5%D1%80%D0%B8%D0%BC%D0%B5%D0%BD%D1%82%D1%8B_%D1%81_%D0%BC%D0%B0%D1%81%D1%81%D0%B8%D0%B2%D0%B0%D0%BC%D0%B8.pdf)
