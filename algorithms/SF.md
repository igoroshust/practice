#### Константный, или постоянный по времени, алгоритм O(1)
Константным, или постоянным по времени, называется алгоритм, который выполняет необходимое действие всегда за одинаковое
количество времени (с точностью до небольшого множителя, вызванного техническими характеристиками вычислительной машины).

К таким алгоритмам относят очень простые операции:
- Присваивание;
- Арифметические операции;
- Логические операции;
- Сравнение объектов;
- Другие действия.

#### Линейный алгоритм (O(n))
Более сложные алгоритмы уже могут зависеть от количества входных данных. Например, если вам нужно найти максимальный
элемент в списке, то самый простой способ - пройтись по всем элементам списка. Здесь контстантного времени уже не хватит,
потому что велика разница между поиском максимального среди 3 элементов или среди 3 миллионов элементов.

Однако больше ни от чего такой поиск не зависит - чем больше элементов, тем больше времени нужно, и количество времени
возрастает в тоже самое количество раз, как и размер списка. Такие алгоритмы называют линейными.
Например, пространственная сложность приготовления ужина зависит от количества гостей на нём. Чем больше гостей, тем больше
тарелок придётся мыть после них. 


#### Логарифмический алгоритм (O(log n))
Логарифмическая сложность - когда на каждом шаге размер проблемы уменьшается вдвое (или в k раз). Это очень эффективно:
для n = 1000000 шагов всего ~20 (поскольку 2^20 = 1000000).
Бывают ситуации, когда алгоритмы могут работать быстрее, чем линейные: самые распространённые - логарифмические алгоритмы.
Их название напрямую связано с тем, как возрастает временная сложность алгоритма с ростом размера входных данных.
Например, если нужно разрезать лист А4 на 16 частей. Если разрезать пополам, потом сложить их и разрезать сразу оба, а
получившиесся четверти снова сложить и снова разрезать, но уже сразу 4 штуки и т.д. - это и есть логарифмический алгоритм.



#### Квадратичный алгоритм (O(n^2))
Квадратичный алгоритм - время выполнения алгоритма растёт пропорционально квадрату размера входных данных.
Такие алгоритмы просты в реализации, но их применяют только для небольших данных или как часть более сложных структур.
Пример: простые сортировки (пузырьковая, вставками), поиск дубликатов в списке без оптимизаций.


#### Полиномиальные алгоритмы (O(n^k))
Естественно, бывают алгоритмы и сложнее. Линейный алгоритм является частным случаем полиномиальных алгоритмов, а всех их
объединяет, что для обработки n объектов входных данных (чисел, например) требуется n^k операций.

Конкретно: чтобы расставить книги в алфавитном порядке, нам понадобится примерно n^2 операций (квадратичный алгоритм O(n^2))
Почему n^2? Рассмотрим на примере расстановки 10 книг в алфавитном порядке (слева направо):

1) Сначала мы должны найти самую первую книгу: просматриваем одну за одной, чтобы найти, какая должна стоять первой.
Выбираем любую из 10 и сравниваем с каждой, чтобы убедиться, что она должна быть первой, или установить, что сравниваемая
книга должна стоять левее. Всего проводим 9 сравнений. Ставим её на полку.

2) Берём произвольно следующую книгу (вторую) из оставшихся 9. Для неё проводим аналогичную операцию - сравниваем с
оставшимися 8. Таким боразом имеет ещё 8 сравнений.

3) Берём N-ную книгу из 10. Предполагается, что к этому моменту мы уже поставили на полку N-1 книгу. Для сравнения с N-ой
у нас останется 10-N книг. А значит, столько же сравнений.

4) И, наконец, когда остаётся только 2 книги - нам нужно сделать только одно сравнение.

5) И для последней книги мы не должны ничего сравнивать, поэтому просто ставим на полку - имеем 0 сравнений. После этого
завершаем работу "алгоритма"

Проведём расчёты общего количества сравнений. Имеется N операций взятия книги и сравнения с оставшимися. В нашем примере -
это десять - столько раз мы берём произвольную книгу из "кучи" и сравниваем с нераставленными.
Сложим все сравнения, которые мы делали все эти 10 раз:
`9 + 8 + 7 + 6 + 5 + 4 + 3 + 2 + 1 + 0`

В математике такая последовательность чисел называется арифметической прогрессией (каждый последующий член последовательности
отличается от предыдущего на постоянное число). Существует формула для нахождения суммы членов арифметической прогрессии:
мы должны найти среднее арифметическое первого и последнего членов прогрессии и умножить на количество всех членов.

Для нашей арифметической прогрессии имеем:
`(9 + 0)/2 * 10 = 45`. 45 - общее количество операций сравнения, которые мы должны сделать, чтобы расставить книги в про
извольном порядке. А что, если у нас не 10 книг, а какое-то очень большое N? Попробуем обобщить эту формулу.
Здесь 9 - это общее количество книг в "куче" минус единица (потому что нам не нужно сравнивать книгу с самой собой).
Для произвольно большого количества книг это число будет равно N-1. Найденное среднее арифметическое мы должны умножить
на количество книг в куче согласно формуле: `(N-1 + 0)/2 * N`, затем приводим формулу к виду: `0.5N^2 - 0.5N`.

Вспомним, что мы искали что-то похожее на n^2, и мы нашли! Конечно, здесь есть множитель перед квадратом N да ещё и дополнительное
слагаемое. Стоит сказать, что n^2 - только оценка сложности. Для анализа алгоритмов нам, как правило, не нужно знать точный
множитель, а находить только общую зависимость от входных данных.


#### Оценка сложности алгоритма (3 величины)
- "O" большая - верхняя оценка сложности алгоритма. Оценка работы алгоритма в худшем случае (хуже не будет).

- "Ω" (омега) - нижняя оценка сложности. Оценка работы алгоритма в лучшем случае.

- "Θ" (тета) - точная оценка сложности. Точная оценка работы алгоритма.

#### Асимптотическая сложность
При помощи символа "O" можно записывать так называемую асимптотическую сложность алгоритма. Это удобная краткая запись
оценки "проблемности" алгоритма.

| Сложность алгоритма | О-нотация |                                                    Примеры |
|:--------------------|:---------:|-----------------------------------------------------------:|
| Константная         |   O(1)    |                                     Сложение, присваивание |
| Линейная            |   O(n)    |                     Поиск максимального элемента из списка |
| Логарифмическая     | O(log(n)) |                                 Разрезание бумаги на части |
| Квадратичная        |  O(n^2)   |                      Расстановка книг в алфавитном порядке |
| Полиномиальная      |  O(n^k)   |                          Наивное умножение матриц (O(n^3)) |
| Факториальная       |   O(n!)   | Рекурсивная функция для генерации всех перестановок (ужас) |


#### Для чего необходимы сложности
Для ответа на этот вопрос необходимо рассмотреть работы алгоритмов (в условных единицах) различной сложности с некоторыми
примерами размеров данных.

| Сложность/размер входных данных | n = 5       | n = 10      |                  n = 20 |                               n = 30 |
|:--------------------------------|:---------:|-------------:|------------------------:|-------------------------------------:|
| O(1)                            |1|1|                       1 |                                    1 |
| O(log(n))                       |2|3|                       4 |                                    4 |
| O(n)                            |5|10|                      20 |                                   30 |
| O(n^2)                          |25|100|                     400 |                                  900 |
| O(n!)                           |120|3628800|              243290200 8176640000 |  2652528598 1219106821 7601719009280 |

