### Зачем в Python?
- Gil (global interpreter lock): Python не может эффективно использовать много потоков для CPU-задач (GIL блокирует).
Асинхронность обходит это для I/O (80% задач в веб/сервисах)
- Быстрее для сетевых приложений (веб-серверы, чат-боты, API-клиенты). Экономит ресурсы (меньше потоков/процессов)

### Где использовать?
I/O-bound: HTTP-запросы, чтение файлов, БД. Пример: Скачивание 100 URL - синхронно 10с, асинхронно 1c.

### Термины
- Coroutine: "Асихнхронная функция" - код, который может приостанавливаться (yield) и возобновляться
- Event Loop: "Диспетчер" - цикл, который управляет переключением задач.
- Async/Await: Синтаксис для написания корутин

### Связанные термины
- CPU (Central Processing Unit) - центральный процессор компьютера, отвечающий за выполнение инструкций и обработку данных.
- CPU-bound задачи - это задачи, производительность которых ограничена возможностями процессора (мат.вычисления, обработка изображений, компиляция кода)
- I/O (Input/Output) - операции ввода-вывода, связанные с обменом данными между компьютером и внешними устройствами.
- I/O-bound задачи - задачи, производительность которых ограничена скоростью ввода-вывода (работа с файлами, сетевые запросы, запросы к БД, чтение/запись в память)
Для CPU-bound задач:
- Использовать multiprocessing
- Распределять нагрузку между процессами
- Минимизация взаимодстействия между процессами

Для I/O-bound задач:
- Использовать threading
- Применять асинхронные операции
- Оптимизируйте время ожидания ввода-вывода


### Threading (Многопоточность)
Threading - механизм, позволяющий выполнять несколько потоков кода параллельно в рамках одного процесса.
Особенности:
- Делят одно пространство памяти
- Эффективны для I/O-bound задач
- Могут создавать проблемы с синхронизацией
- Не обходят ограничения GIL в PYTHON

### Multiprocessing (Многопроцессорность)
Multiprocessing - механизм, создающий несколько независимых процессов для параллельного выполнения задач.
- Каждый процесс имеет собственное пространство в памяти
- Эффективен для CPU-bound
- Обходят ограничения GIL
- Требуют больше ресурсов

### Сравнение подходов
| Характеристика          | Threading | Multiprocessing |
|------------------------|-----------|-----------------|
| **Память**             | Общая     | Раздельная      |
| **Производительность для CPU-bound** | Низкая      | Высокая       |
| **Производительность для I/O-bound** | Высокая      | Средняя       |
| **Сложность реализации** | Простая   | Сложная         |
| **Ограничения GIL**    | Да        | Нет             |


### GIL (Global Interpreter Lock)
GIL - глобальная блокировка интерпретатора в Python, которая позволяет только одному потоку выполнять Python-код в конкретный момент времени.
Влияние GIL
- Ограничивает параллельное выполнение потоков в CPU-bound задачах
- Не является проблемой для I/O-bound задач
- Упрощает управление памятью
- Является причиной, почему многопоточность в Python не всегда ускоряет выполнение

### Разное по теме
- Event Loop - бесконечный цикл: Что делать дальше? Есть ли готовые задачи? - Выполни их.
Корутины регистрируются в loop через 'await' или 'asyncio.create_task'
Корутина ждёт (await I/O), loop переключается на другую.
Получение loop: `asyncio.run()` (рекомендуемый) `asyncio.get_event_loop()` (старый)
Жизненный цикл event loop:
1. Создай loop (или используй run)
2. Добавь задачи (coro = async_func(); loop.create_task(coro))
3. Запусти loop.run_until_complete()
4. Закрой loop
Аналогия: Диспетчер аэропорта. Самолёты (корутины) ждут взлётной полосы (I/O). Диспетчер (loop) распределяет: "Этот ждёт погоду, следующий - взлетай!"

- Coroutine: Функция с async def, возвращающая объект-корутину (не выполяется сразу)
- await: оператор, приостанавливающий корутину до завершения awaited-объекта (другой coro, task или future)
- Future: специальный объект в асинхронном программировании Python, представляющий собой результат асинхронной операции, которая ещё не завершена.