- print имеет атрибуты flush (flush=True - немедленный вывод) и file (file=f - запись в конкретный файл внутри менеджера)

- Файлы должны оканчиваться пустой строкой (исторически в Unix в конце файла был '\n' для обозначения конца файла)

- Библиотека black позволяет форматировать файл по PEP8 (pip install black; black file_name.py). Возможности откатить изменения нет.
Можно форматировать `ctrl + alt + L` в файле

- Python - объектно-ориентированный ЯП. Главное в языке - объект. Все сущности в Python являются объектами (экземпляр того или иного класса).


#### Объект
- Объект - это экземпляр того или иного класса
У каждого объекта есть атрибуты
- Атрибут объекта называется методом, если его значение - функция

#### Класс
Класс - это шаблон или прототип для создания объектов
На основании класса можно создать много объектов (экземпляров), независимых друг от друга

#### Основные типы
- Строка (str): 'Bogdan'
- Целое число (int): 10
- Логический (bool): True/False
- Список (list): [1, 2, 3] - позволяет хранить элементы разных типов
- Словарь (dict): {'min': 5, 'max': 8} - в словарях хранятся элементы по типу 'ключ': значение

#### Выражение (expression)
Выражение - комбинация значений, переменных и операторов, которая вычисляется и возвращает результат. 
Результатом выражения является значение. В выражении обычно несколько операторов (+, or, in и т.д.)
Результат выражения можно использовать в вызове функциии, либо для присвоения результата другой переменной
Проверить выражение: есть в круглых скобках print() прописать значение и будет выведен результат - это выражение, а если
будет ошибка - инструкция. 

Примеры выражений:
- Математические операции: `x + 3`
- Конкатенация: `'hello ' + 'world'`
- Вызов функции: `math.sqrt(x)`
- Сравнение значений: `x > 5`
- Простые значения: `5`, `'строка'`

#### Инструкция (statements - заявления, инструкция)
Инструкция - это команда, выполняемая интерпретатором Python. При выполнении инструкции происходит определённое действие,
но нет конкретного возвращаемого значения.
Инструкция выполняет действие (создаёт функцию, запускает цикл, возвращает результат функции, импортирует другой модуль).

Примеры инструкций:
- Присваивание значения переменной: `x = 5`
- Условные операторы: `if`, `elif`, `else` (условная инструкция)
- Циклы: `for`, `while`
- Импорт модулей: `import math`
- Функция `print` для вывода данных

#### Основные отличия инструкций от выражений
- Инструкция выполняет действие (например, присваивание)
- Выражение вычисляется и возвращает значение
- Инструкции могут содержать выражения
- Выражения могут использоваться в инструкциях
`x = 5` # инструкция присваивания
`y = x + 3` # инструкция с выражением
`result = y * 2` # инструкция с выражением
`print(result)` # инструкция вывода

+ Вызов функции может быть как выражением, так и инструкцией.
Выражение:
`result = math.sqrt(4)`, `x = print('Hello')`, `value = len([1, 2, 3])`
Инструкция:
`print('Hello')`, `open('file.txt', 'w')`, `math.sqrt(4)`

+ return - это ИНСТРУКЦИЯ, а не выражение. Он выполняет действие - завершает выполнение функции и возвращает значение.

#### Встроенные функции
- print()
- input()
- dir() - отображение имён всех атрибутов объекта
print(dir(__builtins__)) - вывод всех атрибутов для объекта builtins (вывод встроенных в python функций)


#### Переменные
Переменная - ссылка на объект в памяти
Пока есть переменная, объект есть в памяти. Если той же переменной был присвоен другой объект, то прежний объект 
будет удалён из памяти по прошествии времени.

Переменная - это именованная область памяти для хранения данных, состоящая из 3 основных компонентов:
1) Имя переменной;
2) Значение (хранящиеся данные);
3) Адрес в памяти;
Переменные дают возможность повторного доступа к значениям
Тип любой переменной определяется типом присвоенного значения

`age` - публичная переменная, доступная из любой части кода, стандартное соглашение для открытых атрибутов класса 
(рекомендуется в большинстве случаев)

`_age` - защищённая переменная, предназначенная для внутреннего использования, технически доступна извне, но считается "непубличной"
(используется для защиты от конфликтов имён при наследовании, указании на то, что переменная является частью внутренней реализации)

`__age` - приватная переменная (mangling). Python автоматически изменяет имя переменной для предотвращения конфликтов.
Доступ к переменной возможен только внутри класса.
Механизм name mangling: Python добавляет к имени префикс с именем класса - `__age` становится `_ClassName__age`

Пример использования
```python
class Person:
    def __init__(self, age):
        self.age = age  # Публичная
        self._age = age  # Защищённая
        self.__age = age  # Приватная

# Доступ к переменным
person = Person(25)
print(person.age)  # Допустимо
print(person._age)  # Технически допустимо, но не рекомендуется
# print(person.__age)  # Вызовет ошибку AttributeError
print(person._Person__age)  # Доступ к приватной переменной через изменённое имя
```

Именование переменных
1) snake_case : переменные, функции, методы, модули
2) PascalCase : классы
3) kebab-case : пакеты (my-package)
4) UPPER_CASE : константы (DB_PASSWORD)

**Правила работы с переменными**
1) Всегда выбирать осмысленные названия;
2) Использовать имя существительное (name, comments, new_photos);
3) Имя переменной должно отвечать на вопрос: "Что содержит?"
+ Название функций и методов необходимо начинать с глагола (get_data, create_request, merge_names) для указания действия
Имя функции должно отвечать на вопрос: "Что выполняет/возвращает/изменяет?"

Идентификатор - ссылка на место в памяти, где сохраняется объект. И каждая переменная содержит эту ссылку. Переменные не  
содержат значения, они содержат ссылку на объект в памяти.

`id(variable)` - получение адреса объекта в памяти

При каждом новом запуске кода будет разный id, потому что при новом запуске кода объект создаётся заново, то есть нельзя
использовать объекты, которые мы создавали ранее (при предыдущих запусках кода)

```python
my_name = 'Igor'

print(id(my_name))
```








#### Разное
- Комментарии игнорируются интерпретатором Python
- enumerate() - встроенная функция Python, добавляющая счётчик к итерируемому объекту и возвращающая его в виде объекта-итератора.
Она особенно полезна, когда нужно получить доступ как к индексу, так и к значению элементов в цикле.
`enumerate(iterable, start=0)`
enumerate оптимизирована для работы с большими данными и обычно эффективнее ручного подсчёта индексов, так как:
1) Не создаёт дополнительных копий данных;
2) Работает с итераторами напрямую;
3) Минимизирует накладные расходы.

- pwd (print working directory) - утилита командной строки, которая отображает полный путь к текущей рабочей директории.

- casefold() - метод строк для приведения значения в нижний регистр (агрессивная версия lower). Обрабатывает больше частных случаев (немецкая буква В и т.д.)
- center(width[, filler]) - метод строк для центрирования текста (width - длина результирующей строки, filler - заполнитель)
```
name = "мир"
print(name.center(20, '-')) # --------мир---------
```

- string.punctuation - предопределённая констата в модуле string, содержащая все знаки препинания в виде строки.
'!"#$%&\'()*+,-./:;<=>?@[\\]^_`{|}~'

- encode() - метод строк, преобразующий строку в последовательность байтов с использованием указанной кодировки.
Это необходимо для работы с данными, которые нужно сохранить или передать в определённом формате.
`строка.encode(encoding='UTF-8', errors='strict') # errors - способ обработки ошибок при кодировании`
```python
print('мир'.encode()) # b'\xd0\xbc\xd0\xb8\xd1\x80'
```

- translate() - метод строк, использующийся для замены или удаления определённых символов в строке на основе таблицы перевода
`строка.translate(таблица)`
Таблица - обязательный параметр, содержащий правила перевода символов. Создать таблицу можно 2 способами:
1) С помощью str.maketrans() (формирует словарь с ключами и значениями для перестановки) {'a': '4', 'e': '3'} и т.д.
2) Через прямое создание словаря с ASCII-кодами

```python
"""Замена гласных на цифры"""
text = 'tutorial'
table = str.maketrans('aeiou', '43109') # maketrans создаёт таблицу перевода символов (translation table)
result = text.translate(table)
print(result) # t9t0r14l
```

```python
"""Удаление гласных"""
text = 'example'
vowels = 'aeiou'
table = str.maketrans('', '', vowels) # maketrans создаёт таблицу перевода символов (translation table)
result = text.translate(table)
print(result) # xmpl
```

```python
"""Использование ASCII-кодов"""
text = 'test'
table = {116: 84, 101: 69} # t -> T, e -> E
result = text.translate(table)
print(result) # TEST
```

```python
"""Удаление знаков препинания"""
import string

text = 'Hello, world! How are you?'
table = str.maketrans('', '', string.punctuation)
# string.punctuation - предопределённая констата в модуле string, содержащая все знаки препинания в виде строки.
clean_text = text.translate(table)
print(clean_text)
```

- Пример работы с datetime
```python
import datetime as d

print(
    d.MAXYEAR,  # 9999
    d.MINYEAR,  # 1
    d.__all__, # ('date', 'datetime', 'time', 'timedelta', 'timezone', 'tzinfo', 'MINYEAR', 'MAXYEAR', 'UTC')
    d.date.today(), # 2025-10-05
    sep='\n'
)
```

- магические методы не вызываются напрямую, они вызываются как следствие использования операторов в Python

- **Конъюгировать** - процесс соединения или сопряжения чего-либо. 
- **Конъюнкция** (логическое умножение) - логическая операция, возвращающая истину только тогда, когда все входящие в неё
высказывания истинны (И, ^, &, X)
- **Дизъюнкция** (логическое сложение) - логическая операция, возвращающая истину, если хотя бы одно из входящих в неё 
высказываний истино (ИЛИ, V, +)

- hex - Hexadecimal (шестнадцатеричная система счисления). Это способ записи чисел, где используется 16 символов:
0-9 и A-F (A=10, B=11, ..., F=15), потому что 16 = 2^4 удобно для представления двоичных данных (каждый hex-символ = 4 бита)
Используется для:
1) Адресов в памяти, байтов или точных float/int
2) Цвета (в CSS/HTML) вроде #RRGGBB - это тоже hex, но для RGB-компонента (каждые два hex-символа = 0-255). Это подмножество hex для графики.
3) Хэши (MD5), UUID, машинный код.
Простыми словами, hex - как "сжатый двоичный код". Вместо длинного binary (101010100) пишем короче: 0xAA.

- Python не выполняет неявную конвертацию типов значений: 
`'10 + 10 = TypeError: can only concatenate str (not 'int') to str)`
`5 + '10' = TypeError: unsupported operand type(s) for +: 'int' and 'str'`
`5 + 4.5 = 9.5`
`5 + 4.5 = 9.5`
`True + 7 = 8`

Порядок операторов имеет значение
Пример конвертация операторов через магические методы (обяснения неявной конвертации)
```python
test = 5
float_num = 4.5

print(int_num + float_num)  # 9.5
print(int_num.__add__(float_num))  # NotImplemented
print(float_num.__radd__(int_num))  # 9.5 
```

Порядок бъявления операндов имеет значения при конвертации, так как, например, в классе `int` есть метод `__add__`, 
а в классе `float` есть метод `__radd__`, и они работают по разному.


#### PEP8
- Для отступов использовать пробелы вместо Tab
- Длина строк не более 79 символов
- Функции и классы должны быть отделены от других строк кода двумя пустыми строками (в большинстве ЯП одна строка)
- Импорты модулей должны быть на отдельных строках
- Комментарии в конце строки кода должны отделяться по крайней мере двумя пробелами `print(10)  # Two spaces in comment`
- Можно использовать больше 2 пробелов (для выравнивания всех комментариев в одну линию)

Форматирование кода по PEP8 в PyCharm `ctrl + alt + L` 

#### Функции
Созданы для многократного вызова блока кода
- Параметр - переменная, доступная внутри функции
- Аргумент - значение для параметра

Вызов функции можно передать как аргумент при вызове другой функции
```python
def sum_nums(a, b):
    sum = a + b
    return sum

# Результат вызова функции передаётся в этой же функции
print(
    sum_nums(sum_nums(50.5, 20), sum_nums(10, 5)),  # 85.5
)
```
- return - инструкция (statement), инструкция выполняет определённые действия
- вызов функции - выражение
- Если в функции нет return, она возвращает None
- Функция print возвращает None всегда (-> None)
```python
print(
    print('Bogdan')
)
# Bogdan
# None
```

Результат вызова функции можно присвоить переменной
```python
first_sum = sum_nums(10, 5)
print(first_sum)
```


#### Статическая и динамическая типизация
Тип переменной определяется во время выполнения программы
ЯП деляется на языки со статической и динамической типизацией
Python - динамически типизируемый язык
```python
String a = 'abc' # статическая типизация
a = 'abc' # динамическая типизация
```

Пример динамической типизации в Python
```python
def print_name(name):
    print(name)

print_name('Bogdan')

print_name = 15

print_name('Bogdan')  # TypeError: 'int' object is not callable
```

#### Типы и структуры данных
1) В Python отсутствуют примитивные типы. В Python все сущности - объекты, и когда мы создаём переменную с типом int, то
в памяти компьютера создаётся объект типа 'int', и этот объект является экземпляром класса int. Если значение 10, то
создаётся один объект в памяти, если создали другое число (15) и присвоили его другой или той же переменной, то
создаётся новый объект в памяти, который также является экземпляром класса 'int', но он не зависит от объекта с числом 10

Примитивные типы данных - это базовые типы данных в программировании, которые представляют собой простейшие значения без
внутренней структуры. Обычно примитивные типы: хранятся в стеке, являются неизменяемыми, занимают меньше памяти, работают 
быстрее сложных типов. В Python все типы являются объектами и нет строгого разделения на примитивные и непримитивные типы.
Даже базовые типы имеют методы и свойства. Условно "примитивными" (базовыми) можно назвать типы int, float, bool, str.
Отсутствие примитивных типов связано с ООП-подходом, динамической типизацией, единым механизмом работы со всеми типами данных.

Примитивные типы данных (primitive data types) - это фундаментальные, встроенные в ЯП типы, представляющие собой простейшие
единицы информации. ОНИ НЕ ЯВЛЯЮТСЯ ОБЪЕКТАМИ ИЛИ СТРУКТУРАМИ, а хранятся напрямую в памяти (обычно в стеке), что делает их
эффективными по скорости и памяти. В отличие от составных (или ссылочных) типов, таких как классы, массивы или строки, 
примитивные типы не имеют методов и не требуют создания экземпляров. Примитивные типы варьируются от ЯП, но в среднем они
включают в себя: int, byte, short, long, float, double, char, bool, void

Примитивные типы - основа любого кода: они используются для расчётов, условий и циклов. Их понимание помогает оптимизировать
производительность и избежать ошибок, таких как переполнение (overflow) для чисел.

2) В Python существуют изменяемые и неизменяемые объекты. Например, объект с типом int является неизменяемым: его нельзя 
изменить, возможно создать новый объект с другим значением. Другой пример - список, его можно изменять (добавлять/удалять элементы),
при этом сам объект остаётся в памяти, и мы изменяем этот объект.
Изменяемые объекты - mutable objects (мутабельные), мутировать - изменить объект без создания нового объекта
Неизменяемые объекты - immutable object (немутабельные)

**Неизменяемые объекты**
1) Строки (str)
2) Логический (bool)
3) Целые числа (int)
4) Вещественные (float)
5) Кортежи (tuple)
6) Ничто (None)

**Изменяемые объекты**
1) Список (list)
2) Словарь (dict)
3) Множества (set)
4) user-defined class (пользовательские классы) - экземпляры классов, созданные разработчиком

**Дополнительно по теме**
1) Python может кэшировать immutable объекты для экономии памяти: 
- Маленькие целые числа (`int` от -5 до 256) интернируются (хранятся в едином пуле)
- Строки тоже могут интернироваться (особенно коротки или литералы)

2) В python переменные - это ссылки на объекты в памяти. Присваивание не копирует данные, а создаёт новую ссылку

Пример создания нового объекта для неизменямых типов:
```python
"""Для int"""
a = 5  # Создаётся immutable объект int со значением 5
b = a  # b ссылается на тот же объект
print(id(a), id(b))  # id(a) == id(b)

a = a + 1  # Создаётся НОВЫЙ объект 6, a теперь ссылается на него
print(a, b)  # 6 5 (b остался на старом объекте)
print(id(a), id(b))  # id(a) != id(b)
```

```python
"""Для str"""
s1 = 'Hello'
s2 = s1
print(s1, s2) # Hello Hello
print(id(s1), id(s2))  # id(a) == id(b)

s1 += ' world'  # Создаётся новый str 'hello world'; s1 перессылается
print(s1, s2)  # Hello world Hello
print(id(s1), id(s2))  # id(a) != id(b)
```

Пример создания новых значений для изменяемых типов
```python
"""Обычное изменение"""
lst1 = [1, 2, 3]  # Создаётся mutable объект list
lst2 = lst1  # lst2 ссылается на тот же объект
lst1.append(4)  # Изменение объекта "на месте"

print(lst1, lst2)  # [1, 2, 3, 4] [1, 2, 3, 4] (оба изменились)
print(id(lst1), id(lst2))  # id(lst1) == id(lst2)
```

```python
"""Создание поверхностной копии"""
import copy
lst1 = [1, 2, 3, 4]  # Создаётся mutable объект list
lst2 = copy.copy(lst1)  # Поверхностная копия
lst1.append(5)

print(lst1, lst2)  # [1, 2, 3, 4, 5] [1, 2, 3, 4]
print(id(lst1), id(lst2))  # id(lst1) != id(lst2)
```

- Интернировать - Термин интернировать (или интернирование, от англ. interning) — это специальный механизм оптимизации памяти 
в языках программирования (в первую очередь в Python, но также в Java, Lisp и других). Он означает создание и 
хранение единственного экземпляра (копии) объекта для одинаковых значений, чтобы избежать дублирования в памяти.
Вместо создания новых объектов для каждого одинакового значения, программа использует ссылку на существующий "канонический"
(стандартный) объект из специального пула (intern pool или cache).

#### CPython
CPython - это эталонная и наболее распространённая реализация (интерпретатор, а не версия!) ЯП Python. Фактически это официальный интерпретатор байт-
кода Python, который написан на языке C. Особенность в том, что CPython не компилирует Python-код в C, а преобразует его
в байт-код, который затем интерпретируется виртуальной машиной. Существуют и другие реализации (PyPy, Jython), но CPython - 
основная.

CPython - это программа, которая читает и выполняет кода на Python. Она написана на C (быстром и низкоуровневом), и это
самая популярная версия Python.

При скачивании Python с официального сайта мы получаем именно CPython. Это наиболее популярная версия языка.
Проверить, что мы используем CPython
```python
import platform
print(platform.python_implementation()) # CPython
```


#### Строки
Строка - последовательность символов. Каждая строка - экземпляр класса str (встроенный класс).
Рекомендация использовать одинарные кавычки для одного слова, двойные - для многословных строк.
Есть другая рекомендация: выбрать один стиль оформления кавычек и придерживаться его для написания кода.

`type(встроенный класс)` всегда возвращает <class 'type'>
```python
print(type(str)) # <class 'type'>
print(type(bool)) # <class 'type'>
```

#### Вещественные числа (float)
Вещественные числа в Python - это числа с плавающей точкой, экземпляры класса float.
Большинство методов вещественных чисел - это специальные (dunder-методы, как `__add__`), которые используются автоматически
при операциях (например, сложение), но есть и публичные методы, которые можно указать явно.

Float в Python - это двойная точность (64 бита), так что методы учитывают это (возможны неточности из-за двоичного представления,
как 0.1 + 0.2 != 0.3)

**Основные публичные методы и свойства для float**
`fl = 24.4`

- as_integer_ratio() - возвращает дробь в виде кортежа (числитель, знаминатель). Возвращает представление float как 
несократимой дроби в виде кортежа `(числитель, знаминатель)`. Это полезно, чтобы понять точное значение числа без ошибок
плавающей точки (float хранится в двоичном виде, так что 0.1 не точно 1/10). Используется для точных вычислений с дробями,
отладки или когда нужно избежать неточностей float.

`print(fl.as_integer_ratio())  #  (122, 5), т.к. 24.4 = 122/5`
`print(0.1.as_integer_ratio())  #  (3602879701896397, 36028797018963968) точное представление 0.1 в двоичном виде`

- conjugate() - возвращает комплексно-сопряжённое число (для float это само число, так как оно реальное).
Используется в основном для комплексных чисел, для float практически бесполезен
`print(fl.conjugate())  # 24.4`

- fromhex(string) - классовый метод: создаёт float из шестнадцатеричной строки (hex-формата), которая представляет число
в формате IEEE 754 (стандарт для float). Строка должна начинаться с '0x' или быть чисто hex-цифрами.
Используется для чтения/записи точных float-значений в hex-формате (полезно на низкоуровневом программировании, сериализации
данных или отладке бинарных файлов).
`print(fl.fromhex('0x33'))  # ~5.1e-323`

- hex() - возвращает hex-представление числа. Показывает точное битовое хранение числа в 64 битах (мантисса + экспонента),
без потерь десятичного вывода. Hex - компактный способ писать большие двоичные числа (каждый hex-символ = 4 бита).
`print(fl.hex())  # 0x1.8cccccCCCCDP+4`

- is_integer() - проверяет, является ли число целым (например, 24.0 - True, 24.1 - False). Используется для проверки
возможности преобразования в int, или в валидации данных (например, 'это пиксели?')
`print(fl.is_integer)  # False`

**Особенности работы с float (0.1 + 0.2 != 0.3, а равно 0.300000000000004)**
Это связано с тем, что компьютеры хранят числа в двоичной системе (как 0 и 1), а не в десятичной, как мы привыкли (0.1 = 1/10)
Многие десятичные дроби (включая 0.1 и 0.2) не могут быть точно представлены в двоичном виде - они становятся "приближением".
В результате сложения таких "приближенных" значений результат получается "грязным" (не идеально 0.3)

Проблемы на практике:
1) Сравнение. `if x == 0.3` может не сработать. Нужно использовать `math.isclose(x, 0.3)` (проверяет, близко ли)
2) Накопление ошибок. В циклах или больших расчётах (финансы, физика), ошибка растёт. Суммируя 0.1 слишком много раз, 
получить не 1.0, а 0.99999999
3) Округление: `round(0.1 + 0.2, 1)` = 3 (помогает), но не всегда
4) Где критично: Деньги (0.1 + 0.2 = ?), графика (пиксели), наука (симуляции). В играх или веб - часто терпимо.

Как решить:
1) Использовать math.isclose()
```python
import math

a = 0.1
b = 0.2

print(
    math.isclose(a+b, 0.3) # True
)
```

2) Использовать модуль decimal (точные десятичные), (идельно подходит для денег)
```python
from decimal import Decimal as D

a = D('0.1')
b = D('0.2')

print(a + b)  # 0.3 - точно!
print(a + b == D('0.3'))  # True
```

#### Комплексные числа (complex)
Используются для различных математических вычислений, а также при обработке данных.
Комплексное число состоит из действительной и мнимой частей. Комплексное число - экземпляр класса complex в Python.

```python
complex_a = 3 + 5j  # 3 - действительная часть, 5 - мнимая + j
complex_b = 4 + 7j

summ = complex_a + complex_b
diff = complex_a - complex_b
mul = complex_a * complex_b
div = complex_a / complex_b

print(
    summ,  # 7+12j (суммируются части по отдельности)
    diff,  # -1-2j 
    mul,  # (-23+41j) = (3 + 5j) * (4 + 7j) = 3*4 + 3*7j + 5j*4 + 5j*7j. 
    #  ВАЖНО! Последнее число 5j*7j (35j) в итоговой формуле будет со знаком минус, и из первого числа вычитаем это число
    # 12 - 35j (последнее число) + 21j + 20j = -12j+41j
    div,  # (0.7230769230769232-0.015384615384615427j)
    type(result)  # <class 'complex'>
)
```

#### Публичные методы целых чисел (int) и bool
Класс `int` реализует несколько полезных публичных методов, связанных с битовой манипуляцией, преобразованиями и рациональными
представлениями (наследуемыми от `numbers.Rational` и `numbers.Complex`)

1) `bit_length(self) -> int`. Возвращает количество бит, необходимых для представления абсолютного значения числа в двоичной системе.
```python
print(
    (10).bit_length(),  # 4 (бинарно: 1010)
    (-10).bit_length(),  # 4
    (100).bit_length(),  # 7
)
```

2) `to_bytes(self, length: int, byteorder: str, *, signed: bool = False) -> bytes`. Преобразует целое число в последовательность
байтов заданной блинны. `byteorder` (способ записи байтов в памяти компьютера) может быть `little` или `big`
`byteorder` определяет, как многобайтовые числа хранятся в памяти и передаются между системами. 
- Big-endian (прямой порядок байтов) - старший байт числа записывается первым. Этот порядок используется в TCP/IP, в файловых
системах и других стандартах
- Little-endian (обратный порядок байтов) - младший байт числа записывается первым. Такой порядок используется в процессорах x86
и некоторых других архитектурах.
```python
print(
    (1024).to_bytes(2, 'big'),  # b'\x04\x00'
    (1024).to_bytes(2, 'little'),  # b'\x04\x04'
)
```

3) `from_bytes(bytes_object: bytes. byteorder: str, *, signed: bool = False) -> int`. Класс-метод создаёт целое число из
последовательности байтов.
```python
print(
    int.from_bytes(b'\x04\x00', 'big'),  # 1024
    int.from_bytes(b'\x04\x00', 'little'),  # 4
)
```

4) `as_integer_ratio(self) -> tuple[int, int]`. Возвращает кортеж (numberator, denominator), представляющий число как 
рациональную дробь (числитель, знаминатель). Для int denominator всегда 1
```python
print(
    (5).as_integer_ratio(),  # (5, 1)
    (10.5).as_integer_ratio(),  # (21, 2)
)
```

5) `conjugate(self) -> int`. Возвращает комплексное сопряжение (для целых чисел - само число, т.к. мнимая часть 0).
Наследовано от `numbers.Complex`
```python
print(
    (3).conjugate(),  # 3
    (4 + 7j).conjugate(),  # (4-7j)
)
```
Комплексное сопряжение - это математическая операция над комплексным числом, при которой знак мнимой части меняется на
противоположный, а действительная часть остаётся неизменной.
(a + bi), где
- a - действительная часть;
- b - мнимая часть;
- i - мнимая единица (i**2 = -1)

Сопряжённое число к a + bi будет иметь вид a - bi

6) `denominator(self) -> int`
Знаменатель рационального представления (всегда 1 для `int`)
`print((7).denominator)  # 1`

7) `numerator(self) -> int`
Числитель рационального представления (само число для `int`)
`print((9).numerator)  # 9`

8) `imag(self) -> int`
Мнимая часть комплексного числа (всегда 0 для `int`)
`print((4).imag)  # 0`
`print((4 + 7j).imag)  # 7.0`

9) `real(self) -> int`
Вещественная часть комплексного числа (само число для `int`)
`print((2).real)  # 2`
`print((4 + 4j).real)  # 4.0`

#### Магические методы
Магические методы - это методы, определённые на уровне того или иного класса. Эти методы наследуются всеми экземплярами классов. 
Магические методы - внутренние методы классов и они обычно не вызываются явно.
У каждого класса свой набор магических методов.
Например, в классе `int` есть метод `__add__`, а в классе `float` есть метод `__radd__`, и они работают по разному. 
Вот почему порядок объявления операндов имеет значения при конвертации.

Магические - потому что явно не вызываются при использовании тех или иных операторов.

Работа магических методы на примере приведения типов
```python
int_num = 10
float_num = 25.7
str_val = 'abc'

print(
    int_num.__mul__(float_num),  # NotImplemented
    int_num * float_num,  # 257.0
    float_num.__rmul__(int_num),  # 257.0
    int_num * str_val,  # abcabcabcabcabcabcabcabcabcabc
    int_num.__mul__(str_val),  # NotImplemented
    str_val.__rmul__(int_num),  # abcabcabcabcabcabcabcabcabcabc
)
```

bool является и классом, и функцией, поскольку с его помощью можно создавать новые экземпляры класса 
bool - это функция-конструктор

Документация по магическим методам
```python
my_list = []
print(my_list.__eq__.__doc__)
print(help(my_list.__eq__))
```


#### Список
Список - упорядоченная последовательность элементов (порядок следования элементов в списке играет роль).
У каждого элемента в списке есть свой уникальный индекс.

Удаление элемента списка
```python
users_inputs = [1, 2 ,3]
del users_inputs[0]
print(users_inputs)  # [2, 3]
```

Список словарей
```python
users = [
    {
        'user_id': 134,
        'user_name': 'Alice'
    },
    {
        'user_id': 831,
        'user_name': 'Bob'
    },
]

print(len(users))  # 2
print(users[0]['user_id'])  # 134
```

Отображение переменных в списке
```python
my_fruit = 'apple'
other_fruit = 'banana'
new_fruit = 'lime'

all_fruits = [my_fruit, other_fruit, new_fruit]

print(all_fruits)  # ['apple', 'banana', 'lime']

my_fruit = 'add'
print(my_fruit)  # add

print(all_fruits)  # ['apple', 'banana', 'lime'] !!!!!! my_fruit не меняется в списке !!!!!!
```
В примере список не меняется, потому что в Python при создании списка происходит копирование значений, а не ссылок на переменные.
Поэтому изменение переменной никак не влияет на значение в списке, потому что список хранит собственную копию исходной
строки 'apple'.

Аналогия: представим, что вы делаем фотографию (список) трёх фруктов. Позже мы меняем один фрукт на другой, но фотография
остаётся прежней, так как она уже содержит зафиксированное изображение.

Если нужно изменить значение в списке, то это делается напрямую:
`all_fruits[0] = 'add'`

Можно использовать подход с динамическим изменением значений
```python
fruits = ['apple', 'banana', 'lime']
my_fruit = fruits[0]  # Получаем ссылку на первый элемент списка
my_fruit = 'add'  # Это создаст новую переменную, не меняя список

# Правильный способ:
fruits[0] = 'add'  # Теперь список изменится
```

Методы списков объекты наследуют от класса List
- append()
- extend()
`list.extend(iterable)`. Используется для добавления элементов из одного списка в конец другого списка
```python
list1 = [1, 2, 3]
list1.extend([4, 5, 6])  # [1, 2, 3, 4, 5, 6]
```

Ещё extend добавляет посимвольно, в то время как append - целиком
```python
my_nums = [10, 50, 0, 5, 5, 100]
my_nums.append('123')  # [10, 50, 0, 5, 5, 100, '123'] 
my_nums.extend('123')  # [10, 50, 0, 5, 5, 100, '1', '2', '3']
```
 
- insert(). Вставка элемента в указанное место (по индексу). 
ВАЖНО! insert() вставляет новый элемент на указанный индекс, не заменяет значение.
```python
my_nums = [10, 50, 0, 5, 5, 100]
my_nums.insert(2, -5)
print(my_nums)  # [10, 50, -5, 0, 5, 5, 100]
```
- pop()
- remove()
- copy()
- reverse()
- sort()
- index()
- count()
- clear()

Копирование списков
```python
lst = [i for i in range(1, 10)]
lst2 = lst[:]  # Создание нового списка (новый объект)
#  lst2 = lst.copy()  # Аналогично, создание нового списка (новый объект)
#  lst2 = list(lst)  # Создание нового списка, используя встроенную функцию list
lst3 = lst  # Копирование по ссылке
lst2.append('213')

print(
    lst,
    lst2,
    lst == lst2,
    lst is lst2,
    sep='\n'
)
```



#### Стек и куча (heap)

#### Структуры данных

#### Методы int

#### Байты, биты

#### Двоичная система счисления

#### Мантисса, экспонента

#### Виды ошибок



