"""Алгоритм"""
# Алгоритм - это последовательность шагов или правил, которые описывают, как решить определённую задачу или выполнить конкретную операцию.
# Алгоритмы могут быть представлены в различных формах, включая текстовые инструкции, схемы, псевдокод или программный код

# Основные характеристики алгоритма (КОВВЭ):
# 1. Конечность: алгоритм должен завершаться после конечного числа шагов.
# 2. Определённость. Каждый шаг алгоритма должен быть чётко определён и не вызывать двусмысленности.
# 3. Входные данные. Алгоритм может принимать входные данные, которые необходимы для выполнения задачи.
# 4. Выходные данные. Алгоритм должен выдавать результат или выходные данные по завершении выполнения.
# 5. Эффективность. Алгоритм должен быть достаточно эффективных, чтобы решить задачу за разумное время и с разумными затратами ресурсов.

# ------------------------------------------- Критерии эффективности алгоритмов ----------------------------------------
# 1. ВРЕМЕННАЯ СЛОЖНОСТЬ АЛГОРИТМОВ говорит нам о том, какое количество времени может потребоваться для выполнения этого алгоритма
# ВРЕМЕННАЯ СЛОЖНОСТЬ АЛГОРИТМОВ зависит от размера входных данных - точно также, как уборка от площади квартиры.

# ВРЕМЕННАЯ СЛОЖНОСТЬ АЛГОРИТМОВ выражается в виде "О-нотации":
# O(1) - Константный алгоритм: Алгоритм выполняется за постоянное время, независимо от размера входных данных (н-р, доступ к элементу массива по индексу);
# Пример: уборка одного конкретного предмета со стола (убрать одну чашу) - время независит от размера комнаты и количества предментов в ней.
# К таким алгоритмам относят очень простые операции: присваивание, арифметические операции, логические операции, сравнение объектов, другие дейтсвия модуля.

# (O(log n)) - алгоритмы с логарифмической сложностью выполняются быстрее, чем линейные, и их время выполнения увеличивается медленнее
# по сравнению с увеличением размера входных данных. Алгоритм делит данные на части (бинарный поиск).
# Пример: лист бумаги режем по полам и складываем каждый раз

# - O(n): Линейный алгоритм. Время выполнения пропорционально количеству элементов (н-р, поиск элемента в неотсортированном массиве);
# Время на уборку пропорционально количеству предметов. Убрать маленькую компнату быстрее, чем большую.

# - O(n^2): Время выполнения пропорционально квадрату количества элементов (н-р, сортировка пузырьком);
# Допустим, мы убираем комнату, и для каждого предмета нам нужно проверить, не мешает ли он другим предметам. Если у нас есть 5 предментов,
# нам нужно будет проверить все их отношения друг к другу, что может занять больше времени. Убираем один предмет - затем проверяем, не мешает ли он другим.


# 2. ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ АЛГОРИТМОВ связана с количеством памяти, которое он использует в своей работе.
# ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ АЛГОРИТМОВ показывает, сколько памяти потребуется алгоритму для выполнения в зависимости от размера входных данных.
# Здесь работает та же аналогия с приготовлением ужина - зависимость от количества посуды, которая загрязняется из-за готовки.
# ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ АЛГОРИТМОВ выражается в виде "О-нотации":

# - O(1) - Алгоритм использует фиксированное количество памяти, независимо от размера входных данных (например, алгоритм использует фиксированное количество переменных)
# Уборка не требует дополнительного пространства. Если мы убираем предметы и складываем их в одну корзину, нам не нужно больше места, независимо от количества предметов.
# Готовим кофе, нужно несколько предметов (чашка, кофейник, ложка, кофе) - незавимо от целей нужно только 1 место для чашки, 1 - для кофейника и т.д.

# (O(log n)) - алгоритмы с логарифмической сложностью выполняются быстрее, чем линейные, и их время выполнения увеличивается медленнее
# по сравнению с увеличением размера входных данных. Алгоритм делит данные на части (бинарный поиск).
# Пример: лист бумаги режем по полам и выделяем место для хранения каждой части.

# - O(n) - Алгоритм использует память, пропорциональную количеству элементов. (создание нового массива, который копирует объекты из другого массива);
# Если используем отдельные контейнеры для каждого типа предметов (одна коробка для книг, другая - для игрушек).
# То есть, требуется пространство пропорциональное колчеству предметов (для 10 книг требуется вместилище для 10 книг).


# - O(n^2) - Алгоритм использует память, пропорциональную квадрату количества элементов. (создаём двумерный массив для хранения всех пар элементов)
# Если решим оранизовать предметы по категориям и подкатегориям (книги по жанрам, внутри жанров - по авторам), нам может понадобиться много места для хранения всех этих категорий.
# Это может привести к ситуации, когда количество используемого пространства растёт пропорционально количеству предменов.


# ------------------------------------------- Оценка сложности алгоритмов ----------------------------------------
# 1. "О" большая - ВЕРХНЯЯ оценка сложности алгоритма. Оценка работы алгоритма в ХУДШЕМ случае. Медленнее этого работать не будет.
# 2. "Ω" Омега - НИЖНЯЯ оценка сложности алгоритма. Оценка работы алгорима в ЛУЧШЕМ случае. Самый быстрый вариант.
# 3. "Θ" Тета - ТОЧНАЯ оценка сложности алгоритма;







"""Примеры алгоритмов"""
# Алгоритмы - это последовательности шагов или инструкций, которые решают определённую задачу.
# Они могут быть простыми и сложными, в зависимости от задачи.

# Простые алгоритмы на Python
# 1. Алгоритм поиска максимального числа в списке (max)
# def find_max(numbers):
#     max_number = numbers[0]
#     for number in numbers:
#         if number > max_number:
#             max_number = number
#     return max_number
#
# numbers = [3, 5, 2, 8, 1]
# print(find_max(numbers))

# 2. Алгоритм сортировки пузырьком. Сортирует список, сравнивая элементы и меняя их метами, если они идут в неправильном порядке.
# Лучший случай (O(n)), средний случай (O(n^2)), худший случай (O(n^2))

# def bubble_sort(arr):
#     n = len(arr) # Общее количество элементов в массиве
#     for i in range(n): # i - текущий индекс или итерация в процессе сортировки или обработки
#         for j in range(0, n-i-1):
#             if arr[j] > arr[j + 1]: # Если текущий элемент больше следующего
#                 arr[j], arr[j+1] = arr[j+1], arr[j]
#     return arr
#
# numbers = [64, 34, 25, 12, 22, 11, 90]
# print(bubble_sort(numbers))  # Вывод: [11, 12, 22, 25, 34, 64, 90]

# 3. Алгоритм вычисления факториала
# def factorial(n):
#     if n == 0:
#         return 1
#     else:
#         return n * factorial(n - 1)
#
# print(factorial(5))

# 4. Алгоритм проверки на простое число
# def is_prime(n):
#     if n <= 1:
#         return False
#     for i in range(2, int(n**0.5) + 1):
#         if n % i == 0:
#             return False
#     return True
#
# print(is_prime(7))
# print(is_prime(10))

# 5. Алгоритм Фибоначчи. Генерирует последовательность Фибоначчи, где каждое число - это сумма двух предыдущих.
# def fibonacci(n):
#     fib_sequence = [0, 1]
#     for i in range(2, n):
#         next_fib = fib_sequence[i-2] + fib_sequence[i-1]
#         fib_sequence.append(next_fib)
#     return fib_sequence[:n]
#
# print(fibonacci(10))

# 6. Бинарный поиск. Эффективный алгоритм для поиска элемента в отсортированном массиве.
# Он работает, деля массив пополам на каждом шаге, что значительно уменьшает количество проверяемых элементов. (Разрез A4)
# Шаг 1. Сравниваем искомый элемент с элементов в середине массива;
# Шаг 2. Если искомый элемент найден, возвращаем его индекс;
# Шаг 3. Если искомый элемент МЕНЬШЕ среднего, продолжаем поиск в ЛЕВОЙ половине;
# Шаг 4. Если искомый элемент БОЛЬШЕ среднего, продолжаем поиск в ПРАВОЙ половине;
# Шаг 5. Проверяем шаги 1-4, пока не найдём элемент или не останется элементов для проверки.

# def binary_search(arr, target):
#     left, right = 0, len(arr) - 1 # Устанавливаем границы поиска
#
#     while left <= right:
#         mid = (left + right) // 2 # Находим середину
#         if arr[mid] == target:
#             return mid # Элемент найден
#         elif arr[mid] < target:
#             left = mid + 1 # Ищем в правой половине
#         else:
#             right = mid - 1 # Ищем в левой половине
#
#     return -1 # Элемент не найден
#
# # Пример использования
# sorted_numbers = [1, 3, 5, 7, 9, 11, 13, 15]
# target = 7
# result = binary_search(sorted_numbers, target)
# print(result) # 3 (индекс 7)

# 7. Сортировка слиянием. Это алгоритм, использующий метод "Разделяй и Властвуй".
# Он делит массив на две половины, сортирует каждую половину и затем объединяет их.

# def merge_sort(arr):
#     if len(arr) > 1:
#         mid = len(arr) // 2 # Находим середину
#         left_half = arr[:mid] # Левая половина
#         right_half = arr[mid:] # Правая половина
#
#         merge_sort(left_half)
#         merge_sort(right_half)
#
#         i = j = k = 0 # Индексы для левой, правой и объединённой половин
#
#         # Объединяем две половины
#         while i < len(left_half) and j < len(right_half):
#             if left_half[i] < right_half[j]:
#                 arr[k] = left_half[i]
#                 i += 1
#             else:
#                 arr[k] = right_half[j]
#                 j += 1
#             k += 1
#
#         # Если остались элементы в левой половине
#         while i < len(left_half):
#             arr[k] = left_half[i]
#             i += 1
#             k += 1
#
#         # Если остались элементы в правой половине
#         while j < len(right_half):
#             arr[k] = right_half[j]
#             j += 1
#             k += 1
#
#     return arr
#
# # Пример использования
# numbers = [38, 27, 43, 3, 9, 82, 10]
# print(merge_sort(numbers))  # Вывод: [3, 9, 10, 27, 38, 43, 82]

# 8. Алгоритм Дейкстры используется для нахождения кратчайшего пути в графе с неотрицательным весами рёбер.
# Он работает, постепенно расиряя известные кратчайшие пути.
# Используется для нахождения кратчайшего пути от одной вершины узла графа до всех остальных вершин. Он работает только с графами, где веса рёбер (дисстанции между узлами) неотрицательные.
# Пример: представим, что у нас есть карта с городами и дорогами между ними. Каждый город - это вершина, каждая дорога - ребро с определённым весом (расстоянием).

# import heapq
#
# def dijkstra(graph, start):
#     # Инициализация расстояний
#     distances = {vertex: float('infinity') for vertex in graph}
#     distances[start] = 0
#     priority_queue = [(0, start)]  # (расстояние, вершина)
#
#     while priority_queue:
#         current_distance, current_vertex = heapq.heappop(priority_queue)
#
#         # Если найдено большее расстояние, пропускаем
#         if current_distance > distances[current_vertex]:
#             continue
#
#         # Проверяем соседей текущей вершины
#         for neighbor, weight in graph[current_vertex].items():
#             distance = current_distance + weight
#
#             # Если найдено более короткое расстояние
#             if distance < distances[neighbor]:
#                 distances[neighbor] = distance
#                 heapq.heappush(priority_queue, (distance, neighbor))
#
#     return distances
#
# # Пример графа
# graph = {
#     'A': {'B': 1, 'C': 4},
#     'B': {'A': 1, 'C': 2, 'D': 3},
#     'C': {'A': 4, 'B': 2, 'D': 1},
#     'D': {'B': 3, 'C': 1}
# }
#
# # Запуск алгоритма Дейкстры
# start_vertex = 'A'
# shortest_paths = dijkstra(graph, start_vertex)
#
# # Вывод результатов
# print("Кратчайшие расстояния от вершины", start_vertex)
# for vertex, distance in shortest_paths.items():
#     print(f"До {vertex}: {distance}")


# Линейный поиск - перебор элементов массива или списка по порядку по момента нахождения искомого значения
# Сортировка вставками - строим отсортированную последовательность слева направо, вставляя каждый новый элемент в нужное место среди уже отсортированных
# Сортировка выбором - на каждом шаге выбираем минимальный элемент из неотсортированной части и меняем его местами с первым элементом этой части
# Быстрая сортировка - выбираем опорный элемент (pivot), разбиваем массив на две части - меньше и больше опороного, рекурсивно сортируем части
# Сортировка подсчётом - сортировка целых чисел из ограниченного диапазона. Считаем, сколько раз встречается каждое значение, а затем восстанавливаем отсортированный массив
# Сортировка Шелла - улучшение сортировки вставками за счёт предварительный сортировки элементов, находящихся на определённом расстоянии (gap)










