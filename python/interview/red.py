# Асимптотическая сложность
# Алгоритмы
# Структуры данных, типы данных
# ООП
# Паттерны проектирования
# Парадигмы программирования

# Docker, Compose, Redis
# SQL, Postgres

# Функции высшего порядка
# Асинхронное программирование
# Замыкание функции
# Рекурсия
# Побочные эффекты
# Односвязный список








"""Алгоритм"""
# Алгоритм - это последовательность шагов или правил, которые описывают, как решить определённую задачу или выполнить конкретную операцию.
# Алгоритмы могут быть представлены в различных формах, включая текстовые инструкции, схемы, псевдокод или программный код

# Основные характеристики алгоритма (КОВВЭ):
# 1. Конечность: алгоритм должен завершаться после конечного числа шагов.
# 2. Определённость. Каждый шаг алгоритма должен быть чётко определён и не вызывать двусмысленности.
# 3. Входные данные. Алгоритм может принимать входные данные, которые необходимы для выполнения задачи.
# 4. Выходные данные. Алгоритм должен выдавать результат или выходные данные по завершении выполнения.
# 5. Эффективность. Алгоритм должен быть достаточно эффективных, чтобы решить задачу за разумное время и с разумными затратами ресурсов.

# ------------------------------------------- Критерии эффективности алгоритмов ----------------------------------------
# 1. ВРЕМЕННАЯ СЛОЖНОСТЬ АЛГОРИТМОВ говорит нам о том, какое количество времени может потребоваться для выполнения этого алгоритма
# ВРЕМЕННАЯ СЛОЖНОСТЬ АЛГОРИТМОВ зависит от размера входных данных - точно также, как уборка от площади квартиры.

# ВРЕМЕННАЯ СЛОЖНОСТЬ АЛГОРИТМОВ выражается в виде "О-нотации":
# O(1) - Константный алгоритм: Алгоритм выполняется за постоянное время, независимо от размера входных данных (н-р, доступ к элементу массива по индексу);
# Пример: уборка одного конкретного предмета со стола (убрать одну чашу) - время независит от размера комнаты и количества предментов в ней.
# К таким алгоритмам относят очень простые операции: присваивание, арифметические операции, логические операции, сравнение объектов, другие дейтсвия модуля.

# - O(n): Время выполнения пропорционально количеству элементов (н-р, поиск элемента в неотсортированном массиве);
# Время на уборку пропорционально количеству предметов. Убрать маленькую компнату быстрее, чем большую.

# (O(log n)) - алгоритмы с логарифмической сложностью выполняются быстрее, чем линейные, и их время выполнения увеличивается медленнее
# по сравнению с увеличением размера входных данных. Алгоритм делит данные на части (бинарный поиск).
# Пример: лист бумаги режем по полам и складываем каждый раз

# - O(n^2): Время выполнения пропорционально квадрату количества элементов (н-р, сортировка пузырьком);
# Допустим, мы убираем комнату, и для каждого предмета нам нужно проверить, не мешает ли он другим предметам. Если у нас есть 5 предментов,
# нам нужно будет проверить все их отношения друг к другу, что может занять больше времени. Убираем один предмет - затем проверяем, не мешает ли он другим.


# 2. ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ АЛГОРИТМОВ связана с количеством памяти, которое он использует в своей работе.
# ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ АЛГОРИТМОВ показывает, сколько памяти потребуется алгоритму для выполнения в зависимости от размера входных данных.
# Здесь работает та же аналогия с приготовлением ужина - зависимость от количества посуды, которая загрязняется из-за готовки.
# ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ АЛГОРИТМОВ выражается в виде "О-нотации":

# - O(1) - Алгоритм использует фиксированное количество памяти, независимо от размера входных данных (например, алгоритм использует фиксированное количество переменных)
# Уборка не требует дополнительного пространства. Если мы убираем предметы и складываем их в одну корзину, нам не нужно больше места, независимо от количества предметов.
# Готовим кофе, нужно несколько предметов (чашка, кофейник, ложка, кофе) - незавимо от целей нужно только 1 место для чашки, 1 - для кофейника и т.д.

# - O(n) - Алгоритм использует память, пропорциональную количеству элементов. (создание нового массива, который копирует объекты из другого массива);
# Если используем отдельные контейнеры для каждого типа предметов (одна коробка для книг, другая - для игрушек).
# То есть, требуется пространство пропорциональное колчеству предметов (для 10 книг требуется вместилище для 10 книг).

# (O(log n)) - алгоритмы с логарифмической сложностью выполняются быстрее, чем линейные, и их время выполнения увеличивается медленнее
# по сравнению с увеличением размера входных данных. Алгоритм делит данные на части (бинарный поиск).
# Пример: лист бумаги режем по полам и выделяем место для хранения каждой части.

# - O(n^2) - Алгоритм использует память, пропорциональную квадрату количества элементов. (создаём двумерный массив для хранения всех пар элементов)
# Если решим оранизовать предметы по категориям и подкатегориям (книги по жанрам, внутри жанров - по авторам), нам может понадобиться много места для хранения всех этих категорий.
# Это может привести к ситуации, когда количество используемого пространства растёт пропорционально количеству предменов.


# ------------------------------------------- Оценка сложности алгоритмов ----------------------------------------
# 1. "О" большая - ВЕРХНЯЯ оценка сложности алгоритма. Оценка работы алгоритма в ХУДШЕМ случае. Медленнее этого работать не будет.
# 2. "Ω" Омега - НИЖНЯЯ оценка сложности алгоритма. Оценка работы алгорима в ЛУЧШЕМ случае. Самый быстрый вариант.
# 3. "Θ" Тета - ТОЧНАЯ оценка сложности алгоритма;



"""Структура данных"""
# Это программная единица, позволяющая хранить и обрабатывать множество логически связанных объектов.

# Виды структур данных: Массивы (статические и динамические) и хэш-таблицы.

# Массив - упорядоченный набор данных. Упорядоченный - хранение этой структуры в памяти каким-то образом организовано.
# Массив - фиксированный набор элементов одного типа, хранящихся в последовательных ячейках памяти. Размер массива задаётся при его создании и не может быть изменён.
# Массивы бывают одномерные, двумерные, трёхмерные и т.д. Их отличительной особенностью является хранение элементов в последовательных ячейках памяти/
# И это становится одним из ограничений массива: при его создании мы всегда должны указывать, какое количество физической памяти нужно для него "забронировать"
# СТАТИЧЕСКИЙ МАССИВ - тот, для которого заранее резервируется определённая область в памяти.
# ДИНАМИЧЕСКИЙ МАССИВ - изменяют свой размер с помощью буферного механизма.

# Важно различать:
# Логический размер массива (logical size) - фактическая заполненность массива;
# Зарезервированный размер памяти (capacity) - фактическая заполненность массива;
# Наиболее выгодное использование массивов возникает в ситуациях частого обращения к элементам массива по индексам, и в
# меньшей степени возникает необходимость добавлять и удалять элементы на произвольное место.
# Пример: Забег легкоатлетов, победители - индекс. Но если кого-то исключили, нужно всех сдвигать.

# Хэш-таблицы - это структуры данных, которые обеспечивают эффективное хранение и поиск данных. Они используют хэш-функцию для преобразования ключей
# в индексы массива, что позволяет быстро находить значения по заданным ключам. Предназначены для хранения данных в паре "ключ-значение". Ключ уникален.
# Словарный тип данных реализует принцип структурирования данных, называющийся хэш-таблицей. Каждое значение обладает ключом доступа к нему.
# Все значения хранятся в обычном массиве (скрытом от нас), а в качестве индекса используется результат хэширования ключа.
# Хэширование (в данном случае) - преобразование объекта, выступающего ключом, в целое число - индекс, используемый для доступа к значению. Ключ должен быть уникальным и не изменяемым.

# Односвязный список. Если в памяти хранится указатель только на следующий элемент, то список называется односвязным. Если указатель и на предыдущий и на следующий - двусвязный список.
# Список - упорядоченный набор элементов. Может быть хаотично распределён в памяти (порядок задаётся наличием указателей на следующий/предыдущий элемент в списке).
# Плюсы cписочного способа хранения:
# 1. Вставка элемента в КОЕНЦ списка (происходит за константное время), если в первой ячейке хранится указатель на последний элемент.
# 2. Вставка элемента в НАЧАЛО списка (происходит за константное время), если в первой ячейке хранится указатель на последний элемент.
# 3. Удаление элемента из НАЧАЛА списка (происходит за константное время).

# Минусы:
# 1. Вставка элемента НА ПРОИЗВОЛЬНОЕ МЕСТО.
# 2. Удаление элемента НА ПРОИЗВОЛЬНОЕ МЕСТО.


# Стек - структура данных, реализующая LIFO. (Стопка тарелок)
# Операции: append (добавить элемент на верх стека), pop (удалить элемент с верха стека), peek (посмотреть на верхний элемент стека без его удаления)
# stack = []
# stack.append(1) # push
# stack.append(2) # push
# print(stack.pop())


# Очередь - структура данных, которая работает по принципу FIFO. То есть, первый добавленный элемент будет удалён. (Очередь к врачу)
# Операции: enqueue (добавить элемент в конец очереди), dequeue (удалить элемент из начала очереди), front (посмотреть на первый элемент очереди без его удаления).
# queue1 = []
# queue1.append(1)
# queue1.append(2)
# print(queue1.pop(0))


# Дерево (Tree) - иерархическая структура данных, состоящая из узлов, где каждый узел может иметь несколько дочерних узлов.
# Удобен для представления иерархий (в виде файловой системы)

# Граф (Graph) - набор узлов и рёбер, соединяющих пары узлов.
# Моделирует сложные взаимосвязи (например, социальные сети).