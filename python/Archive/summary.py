"""генератор списка list comprehension"""
# a = [i**2 for i in range(1, 6)]
# print(a)
"""генератор выражения"""
# a = (i**2 for i in range(1, 6)) # круглые скобки
# print(a)

# генератор - итератор, элементы которого можно итерировать только 1 раз. Генератор изначально сразу является итератором. Генератор - это коллекция, которую можно проитерировать только 1 раз.
# итератор - это объект, который поддерживает функцию next() и помнит о том, какой элемент будет браться следующим
# итерируемый объект - тот, который предоставляет возможность поочерёдно обойти свои элементы и может быть преобразован к итератору. (изначально не представляет из себя итератор).
# Итерация - процесс перебора элементов коллекции внутри функции (или цикла).
# iter()
# Если в программе есть риск большой информации, то нужно использовать выражения генераторы.

# s = [1, 2, 3]
# d = iter(s)
# print(next(d))
# print(next(d))

# yield - используется для превращения обычной функции - в генератор. Исп. в качестве альтернативы return

# def cube_numbers(nums):
#     """Это альтернативый вариант решения тому, что находится ниже (c return)"""
#     for i in nums:
#         yield (i**3)
# cube = cube_numbers([1, 2, 3, 4, 5])
# print(next(cube)) # 1
# print(next(cube)) # 8
# print(next(cube)) # 27
# print(next(cube)) # 64
# print(next(cube)) # 125

# def cube_numbers(nums):
#     cube_list = []
#     for i in nums:
#         cube_list.append(i**3)
#     return cube_list
# print(cube_numbers([1, 2, 3, 4, 5]))

"""декоратор - это функция, позволяющая обернуть другую функцию для расширения её функциональности. Это некая обёртка, которая изменяет работу функции, которую она оборачивает. Они нужны для расширения функционала функции и не повторения блоков кода."""
# первый способ декорирования
# def my_decor(func): # фанк - функция, которую оборачиваем
#     def wrapper():
#         print('start')
#         func()
#         print('end')
#     return wrapper # это не функция, а значение.
# def my_func():
#     print('тут основная функция')
#
# my = my_decor(my_func)
# my()

#второй способ

# def my_decor(func): # фанк - функция, которую оборачиваем
#     def wrapper(n):
#         print('start')
#         func(n)
#         print('end')
#     return wrapper # это не функция, а значение.
# @my_decor
# def my_func(number):
#     print(number**2)
# my_func(10)

"""Пример работы с область видимости переменных"""
# PI = 3.14 # глобальная переменная
#
# def area_circle(r):
#     global PI
#     print("Число, выведенное из локальной области видимости до изменения", PI) # 3.14 (второе значение)
#     PI = 3.1415 # изменение глобальной переменной
#     print("Число, выведенное из локальной обласи видимости после изменения", PI) # 3.1415 (третье значение)
#     return PI * (r**2) # 3.14.150000000000000003 (четвёртое значение)
#
# print("Число, выведенное из глобальной области видимости до вызова функции", PI) # 3.14 (первое значение)
# print(area_circle(10))
# print("Число, выведенное из глобальной области видимости после вызова функции", PI) #3.1415 (пятое значение)














