"""Модуль random"""
import random
import time

# Модуль random() содержит функции по работе со случайными числами (используются в играх, имитационном моделировании, шифровании, стат.анализе)
# Модуль random() предоставляет функции для генерации случайных чисел, букв и случайного выбора элементов последовательности (списка, строки)

# random.randint(a, b) - возвращает случайное число из отрезка [a;b], ВКЛЮЧАЯ a и b в диапазон генерируемых случайных чисел.
# for _ in range(10): # 10 случайных чисел в диапазоне от 1 до 100
#     print(random.randint(1, 100))

# random.randrange() - в отличии от range(), не возвращает саму последовательность чисел, а возвращает случайно выбранное число из последовательности чисел.
# Отличие от range(), что range() создаёт последовательность, а randrange() только число.
# Отличие от randint() - randrange() исключает конечное значение + позволяет указывать шаг random.randrange(1, 10, 2)
# num = random.randrange(10) # случайное число от 0 до 9

# random.random() - возвращает случайное число с плавающей точкой (вещественное число).
# Функция без аргументов, возвращает случайное число с плавающей точкой в диапазоне от 0.0 до 1.0 (исключая 1.0)
# print((num := random.random())) # случайное число от 0.0 до 1.0 (не включая 1.0)

# random.uniform() - возвращает случайное число с плавающей точкой из диапазона значений
# print((num := random.uniform(1.5, 17.3))) # значения включены в диапазон, шаг не поддерживается

# random.seed(17) - явно указываем начальное значение для генератора случайных чисел (т.к. изначально значение зависит от времени на компьютере)
# Использование seed() - полезный способ контролировать генерацию случайных чисел, особенно в ситуациях, когда нужны тесты с одинаковыми условиями.
# random.seed(17)
#
# for _ in range(10):
#     print(random.randint(1, 100))


# random.shuffle() - принимает список в качестве обязательного аргумента и перемешивает его случайным образом.
# numbers = [1, 2, 3, 4, 5, 6, 7, 8]
# random.shuffle(numbers) # например, [7, 4, 2, 5, 6, 1, 3, 8]
# print(numbers)

# random.choice() - принимает список (строку) в качестве обязательного аргумента и возвращает один случайный элемент из переданного списка (строки)
# print(random.choice('BEEGEEK'))
# print(random.choice([1, 2, 3, 4]))
# print(random.choice(['a', 'b', 'c', 'd']))

# random.sample() - принимает два обязательных аргумента: список (строку) и количество случайных элементов, а возвращает список случайных элементов в указанном количестве
# Если количество элементов больеше длинны списка, то будет ошибка ValueError.
# numbers = [2, 5, 8, 9, 12]
#
# print(random.sample(numbers, 1)) # [9]
# print(random.sample(numbers, 2)) # [12, 5]
# print(random.sample(numbers, 3)) # [9, 2, 8]
# print(random.sample(numbers, 5)) # [12, 8, 9, 5, 2]



"""Подбрасывание кубиков"""
# again = 'д'
#
# while again.lower() == 'д':
#     print('Бросаем кубики...')
#     time.sleep(2)
#     print('Значения граней:')
#     print(random.randint(1, 6))
#     print(random.randint(1, 6))
#
#     again = input('Бросить кубики ещё раз? (д - да, н - нет): ')


"""Имитация бросания монеты"""
# for _ in range(10):
#     num = random.randint(0, 1)
#     if num == 0:
#         time.sleep(2)
#         print('Орёл')
#     else:
#         time.sleep(2)
#         print('Решка')


"""Подать число на вход, выдать минимальное количество попыток для угадывания"""
# from math import log2, ceil
#
# n = int(input())
# attempts = ceil(log2(n + 1))
#
# print(attempts)


"""Менеджер контекста"""
# Менеджер контекста - это конструкция, позволяющая управлять ресурсами, такими как файлы, сетевые соединения или блокировки, с автоматическим управлением их открытием и закрытием.
# Он обеспечивает гарантированное освобождение ресурсов, даже если в процессе работы возникли исключения.

# Основные аспекты менеджера контекста
# Менеджеры контекста обычно используются с оператором `with`. Это позволяет автоматически вызывать методы `__enter__` и `__exit__` при входе и выходе из блока `with`.

# Методы
# `__enter__`: метод вызывается при входе в блок `with`. Он возвращает объект, который будет присвоен переменной, указанной после `as`.
# `__exit__`: метод вызывается при выходе из блока `with`, независимо от того, произошло ли исключение. Он принимает 3 аргумента: тип исключения, значение исключения и объект трейсбека

# Пример использования
# Наиболее распространённый пример использования менеджера контекста - работа с файлами
# with open('theory_conspect.txt', 'r') as text:
#    content = text.read()
#    print(content)

 
# Файл автоматически закроется после выхода из блока `with`

# open('example.txt', 'r')- возвращает объект файла, который является менеджером контекста
# при входе в блок `with` файл открывается, а при выходе - автоматически закрывается.

# Преимущества использования менеджера контекста
# 1. Упрощение кода. МК делают код более читаемым и понятным, так как управление ресурсами происходит автоматически.
# 2. Обработка исключений. МК обеспечивают безопасное управление ресурсами, даже если в процессе работы возникают исключения.
# 3. Чистота кода. Уменьшается количество повторяющегося кода, связанного с открытием и закрытием ресурсов.

# Детали
# `open()`: это встроенная функция, использующаяся для открытия файлов. Она возвращает объект файла, который можно использовать для чтения или записи данных.

# Синтаксис функции: open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)
# file - путь к файлу, который мы хотим открыть, mode - режим открытия файла, encoding - кодировка,
# errors - определяет способ обработки ошибок, возникающих при кодировании и декодировании текста. Strict (по умолчанию), ignore (игнорирует ошибки и пропускает некоторые символы),
# replace - заменяет некорректные символы на символ замены (обычно `?`), backslashreplace - заменяет некоторые символы на их эквиваленты в виде escape-последовательностей.
# xmlcharrefreplace - заменяет некоторые символы на соответствующие числовые ссылки в формате XML.
# newline - управляет обработкой символов новой строки. Это полезно при работе с текстовыми данными файлами, которые могут использовать разные символы для обозначения конца строки ('\n', '\r')
# closefd - определяет, будет ли закрыт дескриптор файла, если файл был открыт с помощью дескриптора.
# opener - позволяет указать собственную функцию для открытия файла. Полезно при создании пользовательских механизмов открытия файлов, н-р, для работы с файловыми системами.

# Методы
# .read(size=-1) - считывает содержимое файла. Если параметр size не указан или равен `-1`, то считывается весь файл. Если указан, считывается указываемое количество байт.

# .readline(size=-1) - считывает одну стрку из файла. Если указан параметр `size`, то считывается не более указанного количества байт. Если файл достиг конца, возвращается пустая строка.
# line = file.readline() # Читает первую строку

# .readlines(hint=-1) - считывает все строки файла и возвращает их в виде списка. Параметр `hint` позволяет указать, сколько байт нужно прочитать. Если `hint` не указан или равен `-1`, читаются все строки.
# with open('example.txt', 'r') as file:
#    lines = file.readlines() # Читает все строки в список
#    for line in lines:
#        print(line.strip()) # Убираем символы новой строки

# .write(string) - записывает строку в файл. Если файл открыт в режиме записи (`w` или `a`), то содержимое будет ПЕРЕЗАПИСАНО или ДОБАВЛЕНО.
# with open('theory_conspect.txt', 'w') as file:
#    file.write('Hello, World!\n')

# .writelines(lines) - записывает список строк в файл. Каждая строка списка будет записана в файл без добавления символа новой строки, поэтому, если необходимо, нужно добавлять его вручную.
# lines = ["Line 1\n", "Line 2\n", "Line 3\n"]
# with open('theory_conspect.txt', 'w') as file:
#    file.writelines(lines) # Записывает список строк в файл
#    file.close() # Закрываем файл
#
# with open('theory_conspect.txt', 'r') as text:
#   content = text.read()
#   print(content)

# .flush() - сбрасывает буфер вывода, гарантируя, что все данные, записанные в файл, будут записаны на диск.
# with open('theory_conspect.txt', 'w') as file:
#   file.write('Hello, World!')
#   file.flush() # Сбрасывает буфер

# .close() - закрывает файл. Хотя это автоматически происходит при выходе из блока `with`, можно вызвать этот метод вручную, если файл открыт без менеджера контекста.
# file = open('output.txt', 'w')
# file.write('Hello!')
# file.close()

## Режимы открытия файлов.
# При открытии файла можно указать режим, в котором он будет использоваться:
# 'r' - чтение (по умолчанию)
# 'w' - запись (создаёт новый файл или перезаписывает существующий)
# 'a' - добавление (добавляет данные в конец файла)
# 'b' - двоичный режим (н-р, 'rb' или 'wb' для работы с бинарными файлами)
# 't' - текстовый режим (по умолчанию)

# Пример, как создать новый файл и прочитать его
# with open('new_file.txt', 'w') as file:
#   file.write('Hello!')
    
# with open('new_file.txt', 'r') as file:
#    text = file.read()
#    print(text)

## Когда применяются менеджеры контекста 
# 1. Работа с файлами. Наиболее распространённый случай. Используя `with` можно гарантировать, что файл будет закрыт после завершения работы с ним, даже если возникнет ошибка.

# 2. Сетевые соединения. При работе с сетевыми соединениями, такие как HTTP-запросы, использование менеджера контекста позволяет гаранитровать закрытие соединения после завершения работы.
# import requests

# with requests.get('http://api.example.com/data') as response:
#    data = response.json()
## Соединение автоматически закрывается

# 3. Базы данных;
# 4. Блокировки (многопоточные приложения);
# 5. Работа с временными файлами;
# 6. Управление ресурсами в веб-приложениях;
# 7. Обработка исключений;

# Вывод: МК - универсальный инструмент, позволяющий управлять ресурсами и упрощать код. Он обеспечивает безопасность и чистоту кода, позволяя избежать утечек ресурсов и ошибок, связанных с неправильным управлением ими.
# Использование менеджеров контекста рекомендуется в любых случаях, когда необходимо управлять ресурсами, которые требуют явного освобождения.












