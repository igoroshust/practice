"""Алгоритм"""
# Алгоритм - это последовательность шагов или правил, описывающих, как решить определённую задачу или выполнить действие.
# Алгоритмы могут быть использованы в математике, программировании и повседневной жизни. Они помогают систематизировать процесс
# и гарантируют, что задача будет выполнена правильно и эффективно.


"""Сортировка"""
# Сортировка - это процесс упорядочивания элементов в определённом порядке, н-р, по возрастанию или убыванию.
# Это может быть список чисел, слов или других объектов. Сортировка помогает легче находить информацию и анализировать данные.
# Задача сортировки списка заключается в перестановке его элементов так, чтобы они были упорядочены по возрастанию или по убыванию.
# Это одна из основных задач программирования, с который ИРЛ мы сталкиваемся ежедневно (запись ФИО учащихся в журнале, список призёров соревнований)


"""Алгоритм сортировки"""
# Алгоритм сортировки - это алгоритм упорядочивания элементов в списке. Алгоритмы сортировки оцениваются по скорости выполнения и эффективности использования памяти:
# - время - основной параметр, характеризующий быстродействие алгоритма;
# - память - ряд алгоритмов требует выделения дополнительной памяти под временное хранение данных.
# Алгоритмы сортировки, не потребляющие дополнительной памяти, относят к сортировкам на месте.


"""Основные алгоритмы сортировки"""
# Первая группа: Медленные
# 1. Пузырьковая сортировка (Bubble sort);
# 2. Сортировка выбором (Selection sort);
# 3. Сортировка простыми вставками (Insertion sort).

# Вторая группа: Быстрые
# 1. Сортировка Шелла (Shell sort);
# 2. Быстрая сортировка (Quick sort);
# 3. Сортировка слиянием (Merge sort);
# 4. Пирамидальная сортировка (Heap sort);
# 5. Сортировка TimSort (используется в Java и Python).

# Дополнительно: большинство алгоритмов сортировки основаны на сравнении двух элементов списка, однако не все.
# Такие алгоритмы (не основаные на сравнении), как правило, используют наперёд заданные условия относительно элементов списка.
# Например, элементами списка являются натуральные или целые числа в некотором диапазоне, элементами являются строки и т.д.
# Примеры таких алгоритмов:
# 1. Сортировка подсчётом (Counting sort)
# 2. Блочная сортировка (Bucket sort)
# 3. Поразрядная сортировка (Radix sort)

# Сортировка наглядно: https://www.toptal.com/developers/sorting-algorithms

"""Сортировка пузырьком"""
# Алгоритм сортировки пузырьком состоит из повторяющихся проходов по сортируемому списку.
# За каждый проход элементы последовательно сравниваются попарно и, если порядок в паре неверный, выполняется перестановка элементов.
# Проходы по списку повторяются n-1 раз, где n - длина списка.
# При каждом проходе алгоритма по внутреннему циклу, очередной наибольший элемент списка становится на своё место в конце списка рядом с предыдущим "наибольшим элементов"
# Наибольший элемент каждый раз "всплывает" до нужной позиции, как пузырёк в воде - отсюда и название алгоритма.
# (!) Алгоритм пузырьковой сортировки считается учебным и практически не применяется вне учебной литературы, а на практике применяются более эффективные.

# Пример работы алгоритма:
# a = [5, 1, 4, 2, 8] # -> [1, 5, 4, 2, 8] -> [1, 4, 5, 2, 8] -> [1, 4, 2, 5, 8] -> [1, 2, 4, 5, 8]

# (!!!) В алгоритме пузырьковой сортировки за один проход по списку (внутренний цикл) происходит сравнение и возможный обмен только 1 пары соседних элементов за раз.

# Реализация алгоритма:
# Нужно отсортировать по возрастанию список чисел: a = [1, 7, -3, 9, 0, -67, 34, 12, 45, 1000, 6, 8, -2, 99]

# a = [1, 7, -3, 9, 0, -67, 34, 12, 45, 1000, 6, 8, -2, 99]
# n = len(a)
#
# # Начинаем внешний цикл, который будет выполняться n-1 раз (количество проходов по списку). Каждый проход "выталкивает" наибольший элемент в конец списка.
# for i in range(n - 1):
#     # Внутренний цикл для сравнения соседних элементов
#     for j in range(n - 1 - i):
#         # Если текущий элемент больше следующего, значит, они в неправильном порядке
#         if a[j] > a[j + 1]: # Если порядок элементов пары неправильный
#             a[j], a[j + 1] = a[j + 1], a[j] # Меняем элементы пары местами
#
# print('Отсортированный список: ', a)

# Оптимизация алгоритма
# Если на одном из проходов окажется, что обмены больше не нужны, то это означает, что все элементы списка находятся на своих местах, т.е. список отсортирован.
# Для реализации такого ускорения нужно воспользоваться сигнальной меткой, то есть флажком и оператором прерывания `break`.
# Пример
# for i in range(n - 1):
#     for j in range(n - i - 1):
#         if a[j] > a[j + 1]:
#             a[j], a[j + 1] = a[j + 1], a[j]
#         elif a[j] <= a[j + 1]:
#             continue


"""Сортировка выбором"""
# Сортировка выбором (Selection sort) улучшает пузырьковую сортировку, совершая всего один обмен за каждый проход по списку.
# Для этого алгоритм ищет максимальный элемент и помещает его на соответствующую позицию.
# Как и для Bubble sort, после первого прохода самый большой элемент находится на правильном месте.
# После второго прохода на своё место становится следующий максимальный элемент.
# Проходы по списку повторяются n-1 раз, где n - длина списка, поскольку последний из них автоматически оказывается на своём месте.
# (!) Алгоритм сортировки выбором также считается учебным и практически не применяется вне учебной литературы.

# Пример
# a = [5, 1, 8, 2, 4]
# Первый проход. Находим максимальный элемент (8) в неотсортированной части списка и меняем его на последним элементом списка: [5, 1, 4, 2, 8]
# Второй проход. Находим максимальный элемент (5) в неотсортированной части списка и меняем его с предпоследним элементом списка: [2, 1, 4, 5, 8]
# Третий проход. Находим максимальный элемент (4) в неотсортированной части списка и меняем его с пред-предпоследним элементом списка: [2, 1, 4, 5, 8]
# Четвёртный проход. Находим максимальный элемент (2) в неотсортированной части списка и меняем его с вторым элементом списка: [1, 2, 4, 5, 8]
# Дополнительно: вместо поиска максимального элемента, можно искать минимальный.

# Пример реализации
a = [78, -32, 5, 39, 58, -5, -63, 57, 72, 9, 53, -1, 63, -97, -21, -94, -47, 57, -8, 60, -23, -72, -22, -79, 90, 96, -41, -71, -48, 84, 89, -96, 41, -16, 94, -60, -64, -39, 60, -14, -62, -19, -3, 32, 98, 14, 43, 3, -56, 71, -71, -67, 80, 27, 92, 92, -64, 0, -77, 2, -26, 41, 3, -31, 48, 39, 20, -30, 35, 32, -58, 2, 63, 64, 66, 62, 82, -62, 9, -52, 35, -61, 87, 78, 93, -42, 87, -72, -10, -36, 61, -16, 59, 59, 22, -24, -67, 76, -94, 59]

# n = len(a)
#
# # Внешний цикл, который проходит по всем элементам массива
# for i in range(n):
#     # Предполагаем, что текущий элемент (a[i]) - минимальный
#     min_index = i
#
#     # Внутренний цикл для поиска минимального элемента в неотсортированной части массива
#     for j in range(i + 1, n):
#         # Если найденный элемент меньше текущего минимального, обновляем индекс минимального элемента
#         if a[j] < a[min_index]:
#             min_index = j
#
#     # Меняем местами найденный минимальный элемент с текущим
#     a[i], a[min_index] = a[min_index], a[i]
#
# print(a)










