"""Алгоритм"""
# Алгоритм - это последовательность шагов или правил, описывающих, как решить определённую задачу или выполнить действие.
# Алгоритмы могут быть использованы в математике, программировании и повседневной жизни. Они помогают систематизировать процесс
# и гарантируют, что задача будет выполнена правильно и эффективно.


"""Сортировка"""
# Сортировка - это процесс упорядочивания элементов в определённом порядке, н-р, по возрастанию или убыванию.
# Это может быть список чисел, слов или других объектов. Сортировка помогает легче находить информацию и анализировать данные.
# Задача сортировки списка заключается в перестановке его элементов так, чтобы они были упорядочены по возрастанию или по убыванию.
# Это одна из основных задач программирования, с который ИРЛ мы сталкиваемся ежедневно (запись ФИО учащихся в журнале, список призёров соревнований)


"""Алгоритм сортировки"""
# Алгоритм сортировки - это алгоритм упорядочивания элементов в списке. Алгоритмы сортировки оцениваются по скорости выполнения и эффективности использования памяти:
# - время - основной параметр, характеризующий быстродействие алгоритма;
# - память - ряд алгоритмов требует выделения дополнительной памяти под временное хранение данных.
# Алгоритмы сортировки, не потребляющие дополнительной памяти, относят к сортировкам на месте.


"""Основные алгоритмы сортировки"""
# Первая группа: Медленные
# 1. Пузырьковая сортировка (Bubble sort);
# 2. Сортировка выбором (Selection sort);
# 3. Сортировка простыми вставками (Insertion sort).

# Вторая группа: Быстрые
# 1. Сортировка Шелла (Shell sort);
# 2. Быстрая сортировка (Quick sort);
# 3. Сортировка слиянием (Merge sort);
# 4. Пирамидальная сортировка (Heap sort);
# 5. Сортировка TimSort (используется в Java и Python).

# Дополнительно: большинство алгоритмов сортировки основаны на сравнении двух элементов списка, однако не все.
# Такие алгоритмы (не основаные на сравнении), как правило, используют наперёд заданные условия относительно элементов списка.
# Например, элементами списка являются натуральные или целые числа в некотором диапазоне, элементами являются строки и т.д.
# Примеры таких алгоритмов:
# 1. Сортировка подсчётом (Counting sort)
# 2. Блочная сортировка (Bucket sort)
# 3. Поразрядная сортировка (Radix sort)

# Сортировка наглядно: https://www.toptal.com/developers/sorting-algorithms

"""Сортировка пузырьком"""
# Алгоритм сортировки пузырьком состоит из повторяющихся проходов по сортируемому списку.
# За каждый проход элементы последовательно сравниваются попарно и, если порядок в паре неверный, выполняется перестановка элементов.
# Проходы по списку повторяются n-1 раз, где n - длина списка.
# При каждом проходе алгоритма по внутреннему циклу, очередной наибольший элемент списка становится на своё место в конце списка рядом с предыдущим "наибольшим элементов"
# Наибольший элемент каждый раз "всплывает" до нужной позиции, как пузырёк в воде - отсюда и название алгоритма.
# (!) Алгоритм пузырьковой сортировки считается учебным и практически не применяется вне учебной литературы, а на практике применяются более эффективные.

# Пример работы алгоритма:
# a = [5, 1, 4, 2, 8] # -> [1, 5, 4, 2, 8] -> [1, 4, 5, 2, 8] -> [1, 4, 2, 5, 8] -> [1, 2, 4, 5, 8]

# (!!!) В алгоритме пузырьковой сортировки за один проход по списку (внутренний цикл) происходит сравнение и возможный обмен только 1 пары соседних элементов за раз.

# Реализация алгоритма:
# Нужно отсортировать по возрастанию список чисел: a = [1, 7, -3, 9, 0, -67, 34, 12, 45, 1000, 6, 8, -2, 99]

# a = [1, 7, -3, 9, 0, -67, 34, 12, 45, 1000, 6, 8, -2, 99]
# n = len(a)
#
# # Начинаем внешний цикл, который будет выполняться n-1 раз (количество проходов по списку). Каждый проход "выталкивает" наибольший элемент в конец списка.
# for i in range(n - 1):
#     # Внутренний цикл для сравнения соседних элементов
#     for j in range(n - 1 - i):
#         # Если текущий элемент больше следующего, значит, они в неправильном порядке
#         if a[j] > a[j + 1]: # Если порядок элементов пары неправильный
#             a[j], a[j + 1] = a[j + 1], a[j] # Меняем элементы пары местами
#
# print('Отсортированный список: ', a)

# Оптимизация алгоритма
# Если на одном из проходов окажется, что обмены больше не нужны, то это означает, что все элементы списка находятся на своих местах, т.е. список отсортирован.
# Для реализации такого ускорения нужно воспользоваться сигнальной меткой, то есть флажком и оператором прерывания `break`.
# Пример
# for i in range(n - 1):
#     for j in range(n - i - 1):
#         if a[j] > a[j + 1]:
#             a[j], a[j + 1] = a[j + 1], a[j]
#         elif a[j] <= a[j + 1]:
#             continue


