# Как можно работать асинхронно в Python
# Контекстный менеджер
# async, await, with, files(читать с with),
# Синтаксис (правила написания кода), Семантика (что именно делает код), Типизация, Парадигмы
# Мутабельный и немутабельный.
# Миксины, Пермишины, Сигналы, Работа с почтой
# Что такое типы данных
# CRUD
# Функции высшего порядка
# REST + REST API
# Дженерики в Python
# _ - защита какая-то при объявлении переменной с нижним подчёркиванием
# async await
# asyncio + получение данных с jsonplaceholder
# Парсер
# Императивное, декларативное программирование
# Декоратор
# Операция, программа, инструкция, выражения
# hasattr, setattr
# setter, getter, property
# dependency injection
# Рекурсивная функция.
# items(), zip(), map(), filter() + отличие map от фильтер
# Функция - что это? + Переменная - что это?
# Docker, Compose
# Алгоритмы сортировки
# Что такое переменная
# raise
# if __name__ == '__main__'
# __repr__, __str__, __init__, dander methods all
# ООП + SOLID + Принципы ООП
# self
# Как браузер отображает веб страницу
# Протокол - определение, Что такое Http
# Структуры данных
# Что такое типы данных
# Что называют коллекцией в Python
# npm
# ASCII, Unicode
# Asgi, wsgi
# Try, Except, Match, Switch
# Типы ошибок
# СВЯЗИ В ТАБЛИЦАХ ДЖАНГО
# Методы всех типов данных
# Виды ошибок
# Переменная
# Структуры данных
# Пакетные менеджеры
# Менеджеры контекста
# Git
# GitHub
# DjangoORM
# Webpack
# Vite
# PEP8, PyPI, pip
# ZEN OF PYTHON
# Встроенные функции
# Встроенные типы
# Команда
# Инструкция
# Функция
# Метод
# Класс
# Аргумент
# Параметр
# Алгоритмы
# bs4
# МЕСТО ERP в приложении (синхронизация)
# Мутирующие/Немутирующие сущности в пайтон
# Инструкция и Выражение
# ГЕНЕРАТОРЫ ИТЕРАТОРЫ YIELD
# ЗИП МАП ФИЛЬТЕР и другие встроенные малознакомые функции
# ЛЯМБДА-функции
# ДЕКОРАТОРЫ
# ОТЛИЧИЕ WHILE от FOR
# СТАТИКМЕТОД, КЛАССМЕТОД
# ОБЛАСТЬ ВИДИМОСТИ ПЕРЕМЕННОЙ
# МЕТДЫ КОРТЕЖЕЙ И СЛОВАРЕЙ
# Отличие циклов ФОР и ВАЙЛ
# ИТЕРАЦИЯ ИТЕРИРУЕМЫЕ ОБЪЕКТЫ (СПИСОК ИТЕРИРУЕМЫХ ОБЪЕКТОВ) - ГЕНЕРАТОРЫ ИТЕРАТОРЫ
# ОПЕРАЦИИ ОПЕРАТОРЫ ОПЕРАНДЫ ИНСТРУКЦИИ ВЫРАЖЕНИЯ


"""async/await"""
# async. Когда мы используем async, мы создаём корутину.
# Корутина - специальный тип функций, который может приостанавливать своё выполнение и возобновляться позже.
# await. Когда мы используем `await` перед вызовом другой асинхронной функции (корутины), программа приостанавливает выполнение текущей корутины до тех пор, пока не завершится вызванная корутина.
# По типу: "Подожди здесь, пока я получу данные, а затем продолжай".

# import asyncio
#
# async def boil_water():
#     print("Ставим воду на плиту...")
#     await asyncio.sleep(3)  # Ждем 3 секунды, имитируя время закипания
#     print("Вода закипела!")
#
# async def chop_vegetables():
#     print("Нарезаем овощи...")
#     await asyncio.sleep(1)  # Ждем 1 секунду, имитируя время нарезки
#     print("Овощи нарезаны!")
#
# async def main():
#     # Запускаем обе задачи одновременно
#     await asyncio.gather(boil_water(), chop_vegetables())
#
# # Запускаем основную корутину
# asyncio.run(main())


"""Что такое Django"""
# Django - высокоуровневый веб-фреймворк для языка программирования Python, который упрощает разработку веб-приложений.
# Он был создан с целью ускорить процесс разработки и сделать его более удобным, предоставляя разработчикам множество встроенных инструментов и библиотек.

"""Фреймворк"""
# Это набор инструментов, библиотек и правил, который предоставляет структуру для разработки приложений.
# Он упрощает процесс разработки, предоставляя разработчикам готовые решения для распространённых задач.


"""Язык программирования"""
# ЯП - это формальный язык, который используется для написания программ, которые могут быть выполнены компьютером.
# ЯП позволяют разработчикам описывать алгоритмы и структуры данных, а также взаимодействовать с аппаратным обеспечением и операционными системами.
# Основные характеристики ЯП: Синтаксис (правила написания кода), Семантика (что именно делает код), Типизация, Парадигмы


"""Функции (zip, items, filter, map)"""
# zip() - объединяет несколько итерируемых объектов (например, списков или кортежей) в один итератор,
# который генерирует кортежи, содержащие элементы из каждого из переданных итерируемых объектов.
# Она останавливается, когда достигает конца самого короткого итерируемого объекта.
# list1 = [1, 2, 3]
# list2 = ['a', 'b', 'c']
#
# zipped = dict(zip(list1, list2))
# print(zipped)


# items() - метод используется для получения пар ключ-значение из словаря.
# Он возвращает представление в виде итератора, который генерирует кортежи,
# где первый элемент - это ключ, второй - значение.
# my_dict = {'a': 1, 'b': 2, 'c': 3}
#
# for key, value in my_dict.items():
#     print(f'Ключ {key}, Значение: {value}')


# # map() - применяет заданную функцию к каждому элементу итерируемого объекта (например, списка)
# и возвращает итератор с результатами. Это позволяет легко перебирать данные.
# numbers = [1, 2, 3, 4]
# def square(x):
#     return x * x
#
# squared_numbers = map(square, numbers)
# squared_numbers1 = map(lambda x: x*x, numbers) # с помощью lambda
#
# print(list(squared_numbers))

# filter() - применяет заданнную функцию к каждому элементу итерируемого объекта и возвращает итератор,
# содержащий только те элменты, для которых функция вернула True.
# Позволяет отфильтровать данные.
# def is_even(x):
#     return x % 2 == 0
#
# numbers = [1, 2, 3, 4, 5, 6]
# even_numbers = filter(is_even, numbers)
# even_numbers1 = filter(lambda x: x % 2 == 0, numbers)
#
# print(list(even_numbers))


"""Получить ключ по значению (c использованием next)"""
# alphabet_eng = [chr(i) for i in range(ord('a'), ord('z') + 1)]
# numbers = [i for i in range(1, len(alphabet_eng) + 1)]
#
# # Создание словаря
# alphabet_dict = dict(zip(numbers, alphabet_eng))
#
# # Значение, для которого мы хотим найти ключ
# value_to_find = 'h'
#
# # Поиск ключа по значению с использованием next()
# key_found = next((key for key, value in alphabet_dict.items() if value == value_to_find), None) # next() возвращает первый найденный ключ или `None`, если ключ не найден.
#
# # Вывод найденного ключа
# if key_found is not None:
#     print(f"Ключ для значения {value_to_find}: {key_found}")
# else:
#     print(f"Значение {value_to_find} не найдено в словаре.")



"""Создать словарь, где ключ - номер цифры, значение - буква алфавита"""
# alphabet_eng = [chr(i) for i in range(ord('a'), ord('z') + 1)]
# numbers = [i for i in range(1, len(alphabet_eng) + 1)]
#
# print(alphabet_dict := dict(zip(numbers, alphabet_eng)))


"""Куки"""
# Куки - информация, которую хранит браузер по просьбе сервера веб-приложения.
# Куки чаще всего используют для хранения идентификаторов или инофрмации, не требующей безопасного хранения, т.к. она хранится в виде текста.

"""Сессии"""
# Сессии - механизм, позволяющий сохранить состояние пользователя между запросами в приложении.
# Сессии - это более безопасный механизм хранения данных. Отличие сессий от cookie в том, что реальная информация хранится
# на сервере приложения, а в самих куках хранится идентификатор сессии.

"""Миксины"""
# Миксины (mixins) в Django — это специальные классы, которые используются для добавления функциональности к другим классам,
# особенно в контексте представлений (views) и форм (forms).
# Они позволяют повторно использовать код и обеспечивают более чистую и модульную архитектуру.

# Оба подхода - миксины и декораторы - полезны для повторного использования кода, но они служат разным целям и используются
# в разных контекстах: миксины лучше подходят для добавления функциональности к классам, тогда как декораторы удобны для
# изменения поведения функций.


"""Дженерики"""
# Дженерики - это набор классов, которые предоставляет Django. Каждый класс реализует свою логику


"""ORM"""
# ORM - Object Related Mapping - технология, связывающая реляционные БД с принципами ООП.
# Реляционные Базы Данных основаны на таблицах и строках в них.


"""MVC"""
# Архитектурный шаблон, используемый в разработке ПО, который разделяет приложение на 3 основных компонента: Model, View, Controller.
# Model - управление данными и логикой приложения. Она взаимодействует с БД и определяет, какие данные должны быть обработаны и хранимы.
# Модели реализуют работу с данными. Они выступают в качестве посредника между реальной БД и логикой приложения. Посредничество благодаря ORM.
# View - отображение данных пользователю. Интерфейс, показывающий информацию от модели, и позволяющий взаимодействовать с приложением.
# Controller - посредник между моделью и представлением. Обрабаывает пользовательский ввод, взаимодействует с моделью для получения/изменения данных и обновляет представление.

# Преимущества: улучшение организации кода, упрощение тестирования, возможность параллельной разработки различных компонентов.


"""SQL"""
# Structured Query Language - язык структурированных запросов. На нём пишутся команды, с помощью которых можно создавать
# и удалять сущности, а также создавать, искать, обновлять и удалять CRUD-объекты сущностей.


"""Миграции"""
# Механизм, позволяющий управлять изменениями в структуре БД, связанными с изенениями в моделях приложения.
# Миграции позволяют создавать, изменять, удалять таблицы и поляв БД, синхронизируя их с определениями моделей в коде.

# python manage.py makemigrations
# python manage.py makemigrations <app_name>
# python manage.py makemigrations --merge - объединение миграций в одну с целью разрешения конфликтов
# python manage.py makemigrations migrate
# python manage.py makemigrations migrate <app_name>
# python manage.py makemigrations migrate <app_name> zero - обнуление миграций для указанного приложения
# python manage.py showmigrations

"""База данных"""
# БД - упорядоченный набор структурированной информации или данных, которые обычно хранятся в электронном виде в компьютерной системе.
# Присваивание каждому объекту идентификатора обеспечивает упорядоченность БД - каждый объект имеет порядковый номер.

# Реляционные БД - бд, в которых на этапе проектирования заложены предопределённые связи между сущностями.
# Нереляционные БД - бд, которые не используют фиксированную схему и реляционные таблицы для хранения данных, позволяя хранить
# и обрабатывать данные в различных форматах, таких как документы, ключ-значение, графы и колонки, что обеспечивает гибкость и масштабируемость.

# Три типа связи между сущностями: один к одному, один ко многим, многие ко многим.

# Один-к-одному (1:1). Один из объектов одной сущности связан только с одним объектом другой сущности.
# Таблица Users: id (первичный ключ), username, email
# Таблица Profiles: id (первичный ключ), user_id (внешний ключ, ссылается на Users.id), bio, profile_picture.
# В этом примере каждый пользователь может иметь только один профиль, и каждый профиль принадлежит только одному пользователю.

# Один-ко-многим (1:N). Наиболее распространённый тип связи между сущностями. Объекту одной сущности соответствует несколько объектов другой сущности.
# Пример-1. Таблица "Заказ" и "Сотрудник". Каждому сотруднику может соответствовать множество заказов
# Пример-2:
# Таблица Categories: id (первычный ключ), name
# Таблица Products: id (первичный ключ), name, price, category_id (внешний ключ на Categories.id)
# В этом примере одна категория может содержать множество товаров, но каждый товар принадлежит только одной категории.

# Многие-ко-многим (M:N). Несколько объектов связаны с несколькими объектами.
# Например, "Заказ" и "Продукт". В каждом заказе может быть много продуктов, но в тоже время каждый продукт может быть в нескольких заказах
# Когда мы реализуем такую связь, мы всегда должны иметь 3 таблицы: https://skrinshoter.ru/sUQX8LVkXhS
# Table A и Table B относятся к исходным объектам обоих типов. Третья табрица Table A_B хранит в себе связи между объектами первых двух таблиц.
# Пример-2 (Студенты и курсы):
# Таблица Students: id (первичный ключ), name
# Таблица Courses: id (первичный ключ), title
# Таблица Enrollments (связующая таблица): student_id (FK на Students.id), course_id (FK на Courses.id)
# Во втором примере один студент может записаться на множество курсов, и один курс может иметь множество студентов.
# Связующая таблица `Enrollments` позволяет реализовать эту связь.

# ----------- Резюме -----------
# Один к одному (1:1). Один объект связан с одним объектом (пользователь и его профиль)
# Один ко многим (1:N). Один объект связан с несколькими объектами (категория и товары)
# Многие ко многим (M:N). Несколько объектов связаны с несколькими объектами (студенты и курсы)


"""Сущность"""
# Сущность - некоторый объект из реального мира (реальный или абстрактный)
# У каждой сущности есть атрибуты или поля - свойства, характеристики объекта сущности.
# Сущности должны быть однородны. Если атрибут представлен числом, там не должно быть строки.

# Примеры:
# Сущность "Заказ". Атрибуты: номер заказа, время оформления, время выдачи, стоимость, сотрудник, пункт самовывоза или доставка
# Сущность "Продукт". Атрибуты: номер продукта, название, тип продукта, цена
# Сущность "Позиция в заказе". Атрибуты: заказ, продукт, количество.
# Сущность "Сотрудник". Атрибуты: индивидуальный номер, ФИО, должность, номер ТК.




"""Библиотека и фреймворк"""
# Библиотека - набор заранее написанных функций и классов, которые разработчик может использовать для выполнения определённых задач.
# Библиотеки представляют инструменты для решения конкретных проблем.

# Фреймворк - более крупная структура, которая задаёт основу для разработчки приложений.
# Он предоставляет не только набор функций, но и архитектуру, в которой разработчик должен работать.
# В отличие от библиотеки, фреймворк контролирует поток выполнения программы.


"""Декораторы"""
# Декораторы - это функции, которые принимаю другую функцию в качестве аргумента и возвращают новую функцию, изменяя или
# расширяя её поведение. Декораторы часто используются для добавления функциональности к существующим функциям или методам без изменения их кода.

# Пример декоратора
# def my_decorator(func):
#     def wrapper():
#         print('Что-то происходит перед вызовом функции')
#         func()
#         print('Что-то происходит после вызова функции')
#     return wrapper
#
# @my_decorator
# def say_hello():
#     print('Привет')
#
# say_hello()

"""classmethod"""
# classmethod - это декоратор, позволяющий методу класса принимать сам класс в качестве первого аргумента вместо экземпляра.
# Это полезно, когда нужно работать с классом, а не с конкретным экземпляром.
# Используем, когда хотим работать с самим классом, а не с конкретным экземпляром.

# class MyClass:
#     class_variable = 0
#
#     @classmethod
#     def increment_class_variable(cls):
#         cls.class_variable += 1
#
# MyClass.increment_class_variable()
# print(MyClass.class_variable)

"""staticmethod"""
# staticmethod - декоратор, позволяющий определять методы, которые не требуют доступа к экземпляру или классу.
# Это просто обычная функция, которая находится внутри класса, но не имеет доступ к `self` или `cls`.
# Это метод, который не принимает ни класс, ни экземпляр, в качестве первого аргумента. Он просто обычная функция,
# Он просто обычная функция, находящаяся внутри класса, которая логически связана с классом.

# Пример staticmethod (add не зависит от состояния класса или экземпляра и может быть вызван напрямую через класс)
# class Math:
#     @staticmethod
#     def add(x, y):
#         return x + y
#
# result = Math.add(5, 3)
# print(result)


"""@property"""
# @property - это декоратор, позволяющий создавать свойства (properties) для классов.
# @property - это мощный инструмент для создания свойств, которые позволяют управлять доступом к атрибутам и добавлять
# @property - это декоратор, позволяющий управлять доступом к атрибутам класса, создавая свойства.
# позволяет управлять доступом к атрибутам класса, создавая свойства. Это позволяет добавлять логику при получении или установки значений.
# логику в процесс получения и установки значений. Это делает код более чистым, удобным и безопасным.

# class Person:
#     def __init__(self):
#         self._name = name
#
#     @property
#     def name(self):
#         return self._name
#
#     @name.setter
#     def name(self, value):
#         if not value:
#             raise ValueError('Имя не может быть пустым')
#         self._name = value
#
# person = Person("Alice")
# print(person.name) # Bob



"""if __name__ == '__main__'"""
# Конструкция используется для определения, выполняется ли файл как основная программа или импортируется как модуль в другой файл.
# Это позволяет контролировать исполняемый код в зависимости от контекста.
# __name__ - специальная переменная в каждом модуле. Когда модуль запускается напрямую, его __name__ устанавливается
# в строку `__main__`. Если модуль импортируется в другой модуль, его __name__ будет равен имени модуля.

# Назначение: разделение кода, тестирование, упрощение структуры.
# Пример использования:

# (файл my_module.py)
# def greet(name):
#     return f"Hello, {name}!"
#
# if __name__ == '__main__':
#     print(greet("World")) # Если запустить my_module.py напрямую, увидим вывод "Hello, world"

# (другой файл)
# import my_module
# print(my_module.greet("Alice")) При запуске в другом файле будет Hello, Alice




"""Геттеры и Сеттеры"""
# Геттеры и Сеттеры - это методы, использующиеся для получения (геттеры) и установки (сеттеры) значений атрибутов объекта.
# Они позволяют контролировать доступ к атрибутам и добавлять дополнительную логику при их чтении или изменении.
# Часто реализуются посредством свойств (properties), что делает код более чистым и удобным для понимания.
# Геттеры и сеттеры — это полезные инструменты для управления доступом к атрибутам объектов.


# Зачем они нужны?
# 1. Инкапсуляция. Позволяют скрыть внутреннее представление данных и управлять доступом к ним.
# 2. Валидация. Сеттеры могут содержать логику для проверки значений перед их установкой.
# 3. Изменение внутренней реализации. Можно изменить способ хранения данных, не изменяя интерфейс класса.

# class Person:
#     def __init__(self, name, age):
#         self._name = name # защищённый атрибут
#         self._age = age # защищённый атрибут
#
#     @property
#     def name(self):
#         """Геттер для имени"""
#         return self._name
#
#     @name.setter
#     def name(self, value):
#         """Сеттер для имени"""
#         self._name = value
#
#     @property
#     def age(self):
#         """Геттер для возраста"""
#         return self._age
#
#     @age.setter
#     def age(self, value):
#         """Сеттер для возраста с валидацией"""
#         if value < 0:
#             raise ValueError('Возвраст не может быть меньше 0')
#         self._age = value
#
# # Пример использования
# person = Person('Alice', 30)
#
# # Используем геттеры
# print(person.name, person.age, sep='\n')
#
# # Используем сеттеры
# person.name = 'Bob'
# person.age = 35
# # person.age = -2 # Вызовем ValueError
# print(person.name, person.age, sep='\n')



"""__init__"""
# Магический метод __init__ позволяет создать структуру своих будущих экземпляров с помощью атрибутов.
# Магический метод __init__ определяет атрибуты новых экземпляров.
# Магические методы обычно неявно вызываются при выполнении каких-либо операций.

# class User:
#     def __init__(self, name, email): # с помощью self передаём объект с экземпляром.
#         self.name = name
#         self.email = email

"""Разница между методом и функцией"""
# Метод вызывается от конкретного объекта и реализован внутри класса, а функция работает сама по себе.


"""Терминология ООП"""
# ООП - подход к проектирванию и реализации архитектуры программы.
# Объект - некоторый элемент реального мира в цифровом представлении (программе), обладающий индивидуальными свойствами. Н-р, машина
# Объект - экземпляр с собственным состоянием предписываемых ему в классе свойств.

# Класс - совокупность объектов, обладающих общими характерными свойствами, которые однозначно идентифицируют эту группу объектов.
# Класс - про то, какими свойствами и поведением будет обладать объект.

# Метод - функция внутри класса с self в качестве первого аргумента.

# Атрибуты - переменные, позволяющие хранить данные в привязке к определённому экземпляру. Определяют характеристики и свойства объектов.
# peter = User()
# peter.name = 'Peter' # .name - атрибут.
# Атрибуты бывают экзмемплярными (пример 1) и классовыми (пример 2)
# class Dog:
#     species = 'Lorem ipsum' # классовый атрибут
#
#     def __init__(self, name, age): # метод
#         self.name = name # экземплярный атрибут
#         self.age = age # экземплярный атрибут
#
#     def bark(self): # метод
#         print(f'{self.name} says woof!')
#
# dog1 = Dog('Buffy', 2)
# dog2 = Dog('Duffy', 2)
# print(
#     dog1.name,
#     dog2.name,
#     dog1.species,
#     dog2.species,
#     sep='\n'
# )
# dog1.bark()
# dog2.bark()


# Идеология ООП разрабатывалась как попытка связать поведение объекта с его классом. Причина задумки в том, что нам проще воспринимать
# мир в виде объектов, поддающихся определённой классификации.

"""Основные принципы ООП"""
# Инкапсуляция. Это объединение и изолирование всех данных и процессов объекта внутри единой структуры. ( класс ( функции (переменные) функции) класс )
# Это разграничение прав доступа к данному объекту. Благодаря инкапсуляции объект - целостная структура, в которой все процессы и данные объекта находятся
# в тесной связи друг с другом и определяют общие правила доступа к использованию. Будто находятся внутри единой защитной капсулы.
# ~ Например, у машины есть свойства 'завести' (доступно только владельцу) и 'осмотреть' - доступно всем.

# Наследование. Это c способность бъекта являться потомком другого объекта, перенимая его характерные свойства и методы.
# При наследовании потомок перенимает свойства родителя и дополняет их.
# Наследование решает проблему модификации свойств объекта и придаёт ООП гибкость.
# ~ Например, человек произоёшл от обезьяны, унаследовав многие свойства
# ~ Например, легковой автомобиль (класс-потомок) использует родительский класс (езда), добавляя выбор топлива у себя.

# Полиморфизм. Возможность объекта изменять и дорабатывать методы родительского объекта с целью решения прикладной задачи.
# Посредством полиморфизма объекты способны не изменяя названия функции изменять алгоритм решения и возможный результат.
# Например, два средства передвижения относятся к "машина" и имеют класс "Езда". Но в случае катера это будет 'езда по воде',
# а в случае паровоза - езда по рельсам.
# ~ Мальчик-математик и мальчик-физик решат задачу вычисления объёма шара по-разному (расчёт, опыт).

# Абстракция. Выделение главных, наиболее значимых характеристик предмета и, напротив, отбрасываение второстепенных, незначительных.
# ~ Например, список кандидатов в IT и в театр имеет разный спект реквестируемых признаков.



"""Принципы программирования"""
# YAGNI (You Ain't Gonna Need It) - реализуйте только поставленные задачи (не нужно тестировать электронную печь на работу на газу)
# KISS - избегать чрезмерного проектирования и усложнения
# DRY - избегаем повторения одного и тоже кода
# SOLID

"""SOLID"""
# SOLID - набор принципов, помогающих разработчикам создавать более понятный, гибкий и поддерживаемый код.
# Эти принципы особенно полезны при разработке на ООП-языках (Python).

# [S] - Single Responsibility Principle - принцип единой ответственности.
# Каждый класс должен выполнять только одну задачу. Это делает код более понятным и упрощает его поддержку.
# Например, если есть класс, отвечающий за обработку данных и за вывод информации на экран, лучше разделить его на 2 класса.
# ~ Лучше делегировать тестирование команде, чем всё делать самому.

# [O] - Open/Closed Principle - принцип открытости/закрытости. Классы должны быть открыты для расширения, но закрыты для модификации.
# Это значит, что можно добавлять новый функционал, не изменяя существующий код. Достигается посредством наследования и использования интерфейсов.
# Код, который мы пишем, должен быть масштабируемм, то есть должна быть возможность для его расширения.
# Внесение изменений в коде не должно требовать изменений в существующем коде.

# [L] - Liskov substitution principle - принцип подстановки Барбары Лисков. Это принцип ООП, касающийся классов, интерфейсов,
# типов и подтипов. Суть его в том, что каждый подтип должен дополнять, а не заменять базовый тип.
# Объекты подкласса должны быть взаимозаменяемыми с объектами суперкласса. То есть, если у нас есть класс, который использует базовый класс,
# он должен работать корректно и с подклассами. Например, если у нас есть класс `Bird` и подкласс `Pinguin`, то код, который работает с `Bird`,
# должен также работать с `Pinguin` (по возможности).
# ~ Квадрат, это разновидность прямоугольника. То есть подтип типа, который не изменяет сам тип.

# [I] - Interface segregation principle - принцип разделения интерфейса. Ни один клиент не может зависеть от методов, которые он не использует.
# Проще говоря: не добавляйте дополнительные функции в уже существующий интерфейс, добавляя новые методы. Вместо этого создайте новый интерфейс
# и позвольте вашему классу реализовать несколько интерфейсов при необходимости.
# Лучше иметь несколько специализированных интерфейсов, чем один универсальный.
# ~ В приложении добавили китайский язык сабтайтлом к уже существующему русскому вместо создания опции переключения.

# [D] - Dependency Inversion Principle (Принцип инверсии зависимостей). Модули верхнего уровня не должны зависеть от модулей нижнего уровня.
# Оба должны зависеть от абстракций. Это позволяет уменьшить связанность между компонентами системы. В Python это можно реализовать с помощью внедрения зависимостей (dependency injection)



"""args, kwargs"""
# Позиционные аргументы - аргументы зависят от позиции. Меняя порядок, меняем значение.
# def func (a, b, c)
# func(1, 2, 3) - позиционные аргументы

# Именованные аргументы - указание значения параметра в явном виде.
# func(с=3, b=2, a=1)

# *args - функция принимает неограниченное количество позиционных аргументов. args - кортеж
# **kwargs - функция принимает неограниченное количество именованных аргументов. kwargs - словарь
# *args и **kwargs используются для распаковки элементов соответствующего типа.

# Пример args
# def adder(*args):
#     sum_ = 0
#     for n in args:
#         sum_ += n
#
#     return sum_
# print(adder(1, 2, 3, 10))
#
# # Пример kwargs
# def print_info(**kwargs):
#     for key, value in kwargs.items():
#         print(f'{key}: {value}')
#
# print_info(name='Alice', age=30, city='New York')
#


"""Функции"""
# Функции – обособленный участок кода, который можно вызвать несколько раз, обратившись к нему по имени, которым он был назван.
# Функция - это блок кода, который начинается с ключевого слова def, затем следует название функции и двоеточие в конце.
# При вызове функции происходит выполнение команд тела функции (команд, находящихся внутри функции).

# Для чего нужны функции?
# 1. Структурирование кода. Повышает читабельность;
# 2. Выполнение одной задачи несколько раз;
# 3. Выполнение одной задачи с различными входными данными.

# Параметры в функции - это переменные, которые определяются при объявлении функции. Параметры определяют, какие данные функция ожидает получить.
# Параметры - значения, которые функция готова принимать извне для обработки и изменения результата своей работы.
# def greet(name): # 'name' - это параметр!
#     print(f'Hello, {name}')

# Аргументы - это фактические значения, передаваемые функции при её вызове.
# Аргументы могут являться константами, переменными или выражениями, которые соответствуют параметрам функции.
# greet('Igor') # - это аргумент

# Аргументы бывают обязательными и необязательными.
# Обязательные аргументы - должны быть переданы функции при её вызове.
# def multiply(a, b):  # 'a' и 'b' — обязательные аргументы

# Необязательные аргументы - аргументы, имеющие значения по умолчанию. Если не передаём значение, используем значение по умолчанию.
# def greet(name, greeting="Hello"):  # 'greeting' — необязательный аргумент с значением по умолчанию

# Возвращаемое значение - то, что мы получаем в результате выполнения работы функции.

"""Итератор"""
# Итератор - объект, позволяющий получить доступ к следующему элементу в последовательности.
# Итератор - объект, реализующий протокол итерации, состоящий из 2 методов:
# - `__iter__()` - возвращает сам итератор
# - `__next__()` - возвращает следующий элемент последовательности. Вызывает `StopIteration`, если элементы закончились.

# Пример простого итератора:
# class MyIterator:
#     def __init__(self, max):
#         self.max = max
#         self.current = 0
#
#     def __iter__(self):
#         return self
#
#     def __next__(self):
#         if self.current < self.max:
#             self.current += 1
#             return self.current - 1
#         else:
#             raise StopIteration
#
# for number in MyIterator(5):
#     print(number)

"""Итерация"""
# Итерация - процесс последовательного обхода элементов итерируемого объекта.
# Осуществляется с помощью for, который автоматически вызывает методы `__iter__()` и `__next__()`

# Пример итерации:
# my_list = [1, 2, 3]
# for item in my_list:
#     print(item)

"""Итерируемый объект"""
# Итерируемый объект - это объект, который может быть итерирован, то есть у него есть метод `__iter__()`, который возвращает итератор.
# Примеры итерируемых объектов: списки, кортежи, строки, множества и словари.

# Пример итерируемого объекта:
# my_list = [1, 2, 3]
# iterator = iter(my_list) # (!!!) Получаем iterator из итерируемого объекта.
# print(next(iterator))
# print(next(iterator))
# print(next(iterator))


"""Генератор"""
# Генератор - это специальный вид итератора, который создаётся с помощью функции, содержащей одно или несколько выражений yield.
# Генераторы позволяют создавать итераторы более простым и удобным способом, чем с помощью классов.
# Генератор - это итератор, элементы которого можно итерировать только 1 раз.
# Генераторы позволяют экономить память, так как они создают значения по мере необходимости, а не хранят их все в памяти сразу.

# Пример генератора:
# def my_generator():
#     yield 1
#     yield 2
#     yield 3
#
# for value in my_generator():
#     print(value)

"""Как отличить Итератор от Итерируемого объекта?"""
# 1. Методы.
# Итератор должен реализовать оба метода: `__iter__()` и `__next__()`.
# Итерируемый объект должен реализовать только метод `__iter__()`, который возвращает итератор.

# 2. Использование.
# Итерируемый объект можно использовать в цикле `for` или передать в функцию `iter()`, чтобы получить итератор.
# Итератор используется для последовательного доступа к элементам, и его нельзя использовать повторно после завершения итерации (нужно создать новый итератор)

# Примеры
# Итерируемые объекты: строки, списки, словари, кортежи, множества
# Итераторов: объекты, созданные с помощью пользовательских классов, которые реализуют методы `__iter__()` и `__next__()`, а также генераторы.

# class MyIterable:
#     def __init__(self, max):
#         self.max = max
#
#     def __iter__(self):
#         return MyIterator(self.max) # Возвращаем итератор
#
# class MyIterator:
#     def __init__(self, max):
#         self.max = max
#         self.current = 0
#
#     def __iter__(self):
#         return self
#
#     def __next__(self):
#         if self.current < self.max:
#             self.current += 1
#             return self.current - 1
#         else:
#             raise StopIteration
#
# # Создаём итерируемый объект
# my_iterable = MyIterable(3)
#
# # Используем его в цикле for
# for number in my_iterable:
#     print(number)

# Заключение
# - Итератор - это объект, позволяющий последовательно получать элементы из коллекции и реализует методы `__iter__()` и `__next__()`.
# - Итерируемый объект - это объект, который может быть итерирован и имеет метод `__iter__()`, возвращающий итератор.
# Итератор используется для обхода элементов, а итерируемые объекты служат источником для итераторов.



"""Коллекция и Последовательность"""
# ----------------------- Коллекция -----------------------
# Коллекция - это общее понятие, относящееся к структурам данных, позволяющим хранить и управлять множеством элементов.
# Коллекции могут содержать элементы различных типов и предоставляют различные способы доступа к элементам.

# Типы коллекций:
# - Списки. УПОРЯДОЧЕННАЯ ИЗМЕНЯЕМАЯ коллекция, способная содержать элементы различных типов.
# - Кортежи. УПОРЯДОЧЕННЫЕ НЕИЗМЕНЯЕМЫЕ коллекции.
# - Множества. НЕУПОРЯДОЧЕННЫЕ ИЗМЕНЯЕМАЯ коллекция уникальных элементов. Множества не допускают дубликатов.
# - Словари. НЕУПОРЯДОЧЕННАЯ ИЗМЕНЯЕМАЯ коллекция пар "ключ-значение". Каждый ключ - уникальный, значение - объект любого типа.

# ----------------------- Последовательность -----------------------
# Последовательность - специальный тип коллекции, поддерживающий порядок элементов и позволяет получить доступ к элементам по его индексу.
# - Cписки. Упорядоченная последовательность. Можем обращаться по индексу.
# - Кортежи. Упорядоченная последовательность. Можем обращаться по индексу.
# - Строки. Можем обращаться по индексу.

# ----------------------- Резюме -----------------------
# Коллекция - это общее понятие, охватывающее различные структуры данных, позволяющее хранить множество элементов.
# Последовательность - это подмножество коллекций, поддерживающее порядок элементов и доступ по индексам.


"""Цикл While"""
# Цикл - это конструкция в программировании, позволяющая повторять выполнение определённого блока кода несколько раз.
# Циклы используются для автоматизации повторяющихся задач, что делает код более компактным и удобным для чтения.

# While - тип цикла, выполняющий блок кода до тех пор, пока заданное условие истинно. В начале каждой итерации цикла проверяется условие..
# .. и если оно истино, то выполняется тело цикла. Если условие становится ложным, выполнение цикла прекращается.
# Условный оператор `while` в Python используется для выполнения блока кода, пока заданное условие истино.

"""Цикл For"""
# Цикл For - это конструкция, позволяющая выполнять блок кода несколько раз, перебирая элементы последовательности.
# Используется в ситуациях, когда нужно выполнить тело цикла определённое количество раз.


"""Условный оператор"""
# Условный оператор - это конструкция, позволяющая выполнить определённые блоки кода в зависимости от истинноси или ложности заданного условия.
# Используется для управления потоком выполнения программы, позволяя принимать решения на основе логических выражений.

"""Операторы и операнды"""
# Оператор - обозначение некой операции. Операторы производят действия (операции) над данными.
# Операнды - данные, над которыми выполняются действия.
# 1. Унарные. Для их работы требуется одно значение. Например, not.
# 2. Бинарные. Для их работы требуется два значения. Например, "+".
# 3. Тернарные. Используют три операнда. Например, "value_if_true if condition else value_if_false"

# Виды операторов:
# 1. Операторы сравнения (в результате выдают булеву переменную): # < > <= >= == !=
# 2. Арифметические операторы: + - * / // % **

# 3. Логические операторы: not, and, or,
# 4. Операторы принадлежности: in, not in. Возвращает True, если проверяемая переменная содержится (или не содержится) в последовательности.
# 5. Операторы идентичности: is, is not. Возвращает True, если проверяемые объекты эквивалентны (или не эквивалентны), то есть переменные ссылаются на один и тот же адрес в памяти.

# 4. Побитовые операторы (работают с битами целых чисел): & | ^ ~ << >> : побитовое И ИЛИ ИСКЛЮЧАЮЩЕЕ ИЛИ (XOR) НЕ сдвиг влево вправо
# 5. Присваивание: = += (прибавить или присвоить), -= (вычесть или присвоить), *= (умножить или присвоить), /= (разделить или присвоить) и т.д.


"""Метод"""
# Метод - это функция, которая применяется к определённому объекту, используя символ точку.

"""Вируальные окружения"""
# Виртуальное окружение в Python - это инструмент, который позволяет создавать изолированные среды для проектов, в которых
# можно устанавливать зависимости и библиотеки, не влияя на глобальную установку Python и другие проекты.

# Внутри копируется интерпретатор, от которого данное окружение было создано, и стандартные модули (os, sys, etc...)

"""Каталог Пакетов (PyPI)"""
# В стандартной библиотеке немало модулей и пакетов с ограниченным функционалом, поэтому существует каталог пакетов
# (PyPI - Python Package Index), где содержаться пакеты, написанные другими разработчиками. Все пакеты храняться в репозитории
# на сайте pypi.org. Каждый проект содержит описание, ссылки и исходный код и документацию по использованию.

"""Пакетные менеджеры (pip, pipenv, conda)"""
# Пакетный менеджер (или система управления пакетами) - используется для установки и управления программными пакетами.
# Предоставляют интерфейс, позволяющий с помощью команд установить или удалить пакет по названию.

# pip является модулем, написанным на Python, и позволяет работать только с установкой Python-пакетов.


"""Пакет"""
# Пакет - способ организации модулей в иерархическую структуру. Пакет представляет собой директорию, содержащую один
# или несколько модулей и файл `__init__.py`, указывающий Python, что директория является пакетом.
# Структура: пакеты могут содержать подкаталоги (подпакеты), что позволяет создавать сложные иерархии.

# # Наличие `__init__.py`
# Идентификация пакета. Начилие файла `__init__.py` позволяет Python распознавать и импортировать модули из этой директории.
# Если файл отсутствует, Python не будет рассматривать директорию как пакет и мы не сможем импортировать модули из неё.


"""Что такое зависимости?"""
# Зависимости - это набор модулей и библиотек, необходимых для работы проекта.

"""Что такое библиотека?"""
# Библиотекой (модулем) в Python фактически является любой файл, содержащий программный код. Даже простейший скрипт, содержащий
# всего 1 строку, можно назвать модулем. Программисты пишут модули для решения самых разнообразных задач и публикуют их
# в свободном доступе, чтобы желающие могли подключать их без изобретения велосипеда.

# Библиотека - это более общее понятие, которое обычно относится к набору модулей и пакетов, предоставляющих определённые
# функции или возможности. Библиотека может состоять из одного или нескольких пакетов и модулей

"""Что такое стандартная библиотека в Python?"""
# Это набор модулей и пакетов, которые поставляются вместе с интерпретатором Python и предоставляют множество полезных
# функций и инструментов для разработки программ.

# # Примеры:
# os, sys, math, datetime, json, sqlite3, re, http


"""Что такое IDLE?"""
# IDLE - интегрированная среда разработки и обучения на языке Python (англ. Integrated Development and Learning Environment).
# IDLE предназначена для упрощения процесса написания, тестирования и отладки кода на Python.
# Содержит интерактивную оболочку, редактор кода, отладку. Является частью стандартной библиотеки Python.

"""Что такое IDE?"""
# IDE - интегрированная среда разработки. Это программы для написания програм (IDLE, PyCharm, Spyder, VSCode, PyDev).
# IDE состоит из 3 основных объектов:
# 1. Текстового редактора, позволяющего писать код;
# 2. Транслятора (в Python - интерпретатора), исполняющего код;
# 3. Отладчика, позволяющего пошагово изучить программу и облегчить поиск ошибок.

"""Что такое программа?"""
# Программа - последовательность инструкций, написанных на ЯП, которые выполняются компьютером для выполнения определённой задачи
# или решения конкретной проблемы.

# # --------------- Основные характеристики программы -------------- # #
# 1. Инструкции. Программа состоит из набора команд или инструкций, которые определяют, какие действия должен выполнить компьютер.
# Эти инструкции включают арифметические операции, логические операции, ввод и вывод данных, управление потоком выполнения и другие действия.
# 2. Язык программирования.
# 3. Алгоритмы. Алгоритмы - чётко определённые последовательности шагов для решения задачи.
# 4. Входные и выходные данные. Входные - принимаем от пользователя или из файла, выходные - выводим на экран или записью в файл.
# 5. Исполняемость. Программы могут быть исполняемыми (скомпилированные или интерпретируемые) и могут выполняться на различных платформах.
# 6. Структура. Программы могут иметь различные структуры, включая функции, классы и модули, что позволяет организовать код и сделать его более читаемым или поддерживаемым.


"""Что такое блок-схема?"""
# Это способ графического представления алгоритма, в котором шаги изображаются в виде блоков различной формы, соединённых между собой стрелками.