"""Связи в реляционных БД"""
# 1. Связь 1:1
# Каждой записи в одной таблице соответствует ровно одна запись в другой таблице.
# Пример: Таблицы `Users` и `User Profiles`. Один студен может записаться на несколько курсов, и один курс может быть посещаем несколькими студентами.

# from django.db import models
#
# class User(models.Model):
#     username = models.CharField(max_length=100)
#     email = models.EmailField()
#
# class UserProfile(models.Model):
#     user = models.OneToOneField(User, on_delete=models.CASCADE)
#     first_name = models.CharField(max_length=100)
#     last_name = models.CharField(max_length=100)


# 2. Связь 1:M
# Одной записи в одной таблице может соответствовать несколько записей в другой таблице.
# Пример: Таблицы `Authors` и `Books`

# from django.db import models

# class Author(models.Model):
#     name = models.CharField(max_length=100)
#
# class Book(models.Model):
#     title = models.CharField(max_length=100)
#     author = models.ForeignKey(Author, on_delete=models.CASCADE, related_name='books')
#     # related_name=books позволяет получить доступ к книгам автора через author.books.all()


# 3. Связь M:M
# Одной записи в одной таблице может соответствовать несколько записей в другой таблице, и наоборот.
# Для реализации такого типа связей используется промежуточная таблица.
# Пример: таблицы `Students` и `Courses`

# Таблица `Students`:
# studentID (PK)
# name

# Таблица `Cources`:
# courseID (PK)
# courseName

# Промежуточная таблица `Enrollments` (зачисления):
# enrollmentID (PK)
# studentID (FK)
# courseID (FK)


# class Student(models.Model):
#     name = models.CharField(max_length=100)
#
#     def __str__(self):
#         return self.name
#
# class Course(models.Model):
#     course_name = models.CharField(max_length=200)
#
#     def __str__(self):
#         return self.course_name
#
# class Enrollments(models.Model):
#     student = models.ForeignKey(Student, on_delete=models.CASCADE)
#     course = models.ForeignKey(Course, on_delete=models.CASCADE)
#     enrollment_date = models.DateField()
#
#     class Meta:
#         unique_together = ('student', 'course') # Уникальная пара студент-курс
#
#     def __str__(self):
#         return f'{self.student.name} enrolled in {self.course.course_name} on {self.enrollment_date}'



"""Асинхронное программирование"""
# import asyncio
#
# async def fetch_data():
#     print('Начинаем загрузку данных...')
#     await asyncio.sleep(2) # Имитация асинхронной операции
#     print('Данные загружены!')
#     return {"id": 1, "name": "John"}
#
# async def main():
#     data = await fetch_data() # Ожидание завершения fetch_data
#     print(data)
#
# # Запуск асинхронной функции
# asyncio.run(main())


"""Получить данные по API и записать их в отдельный файл"""
import aiohttp
import asyncio

async def fetch(url):
    async with aiohttp.ClientSession() as session:
        async with session.get(url) as response:
            return await response.json()
async def main():
    url = 'https://jsonplaceholder.typicode.com/posts'
    posts = await fetch(url)

    output = "" # Собираем данные в строку

    for post in posts[:10]:
        output += f'''Post ID: {post['id']}
Title: {post['title']}
{post['body']}
----------------------------------------------------
'''
    return output # Возвращаем собранные данные
if __name__ == "__main__":
    with open('text.txt', 'w') as file:
        text = asyncio.run(main()) # Получаем данные
        file.write(text)



"""Измерение качества архитектуры"""
# 1. Гибкость;
# 2. Масштабируемость;
# 3. Эффективность (соотношение цена/качество);


"""Оператор '*' (распаковка)"""
# a = [1, 2, 3]
# b = [*a, 4, 5, 6]
# print(b)

"""Области видимости"""
# ОВ определяют, в какой части программы мы можем работать с той или иной переменной, функцией и т.д.
# LEGB (Local, ENCLOSING (nonlocal), Global, Bulit-in (print, len, list, etc) - механизм описания порядка поиска имён в различных областях видимости.
# Локальная - ограничена конструкцией.
# def local():
#     x = 5
#     print(x)
#
# x = 10
# local() # 5
# print(x) # 10

# Глобальная - переменная доступная на уровне модуля.
# def local():
#     print(x)
#
# x = 10
# local()
# print(x)

# Нелокальная область видимости. Появилась в Python3 вместе с ключевым словом nonlocal.
# nonlocal используется чаще всего во вложенных функциях, когда мы хотим дать интерпертатору понять, что для вложенной функции
# определённая переменная не является локальной, но она и не является глобальной в общем смысле.
# def get_mul_func(m):
#     nonlocal_m = m
#     def local_mul(n):
#         return n * nonlocal_m
#
#     return local_mul
#
# two_mul = get_mul_func(2)
# two_mul(5)

# Функции образуют локальную область видимости, а скрипты - программную.


"""Функция подсчёта символов в тексте"""
# def char_frequency(text):
#
#     formatted_text = text.lower().replace(' ', '').replace('\n', '')
#     count = {}
#
#     for char in formatted_text:
#         if char in count:
#             count[char] += 1
#         else:
#             count[char] = 1
#
#     for char, cnt in count.items():
#         print(f'Символ {char} встречается {cnt} раз')
#
# char_frequency('''Lorem Ipsum is simply dummy text of the printing and typesetting industry.
#     Lorem Ipsum has been the industry's standard dummy text ever since the 1500s,
#     when an unknown printer took a galley of type and scrambled it to make a type specimen book''')


"""Continue"""
# Оператор `continue` в Python используется внутри циклов для пропуска текущей итерации и перехода к следующей.
# continue выполняет немедленное завершение текущей итерации цикла.
# Это полезно, когда мы хотим выполнить определённые условия, не прерывая весь цикл.

# for i in range(1, 20+1):
#     if i % 2 == 0:
#         continue
#     print(i) # Выводим только нечётные числа.


"""Функция Enumerate"""
# Функция, возвращающая кортежи, где на первом месте стоит индекс элемента, а на втором - его значение.
# enumerate(iterable, start=0) позволяет итерироваться по элементам последовательности и одновременно получать индекс текущего элемента.
# list_ = [-5, 2, 4, 8, 12, -7, 5]
#
# for i, value in enumerate(list_):
#     print("Индекс элемента: ", i)
#     print("Значение элемента: ", value)
#     print("---")
# else:
#     print('Конец цикла')

# fruits = ['apple', 'banana', 'cherry']
# for index, fruit in enumerate(fruits):
#     print(f'Index: {index}, Fruit: {fruit}')



"""Дана двумерная матрица 3х3. Необходимо определить максимум и минимум каждой строки и их индексы"""
# # Моё решение:
# random_matrix = [
#     [9, 2, 1],
#     [2, 5, 3],
#     [4, 8, 5],
# ]
#
# results = []
#
# for row in random_matrix:
#     for element in row:
#         print(element, end=' ')
#         results.append(element)
#     print()
#
# max_results = max(results)
# min_results = min(results)
# print(
#     f'''Максимальный элемент: {max_results}
# Индекс максимального элемента: {results.index(max_results)}
# Минимальный элемент: {min_results}
# Индекс минимального элемента: {results.index(min_results)}'''
# )


"""Вложенные циклы и двумерные массивы"""
# Вложенные циклы чаще нужно для реализации сортировок, работы с двумерными и многомерными массивами, обходах дерева и для некоторых алгоритмов.
# Двумерный массив (матрица) - обычная таблица. Одномерная матрица - списоок, двумерная - список списков.

# Пример двумерного массива
# matrix = [
#     [1, 2],
#     [3, 4],
#     [5, 6]
# ]
#
# # Вложенный цикл для перебора элементов матрицы
# for row in matrix: # перебирает строки (обход строк)
#     for element in row: # перебирает элементы в строке
#         print(element, end=" ")
#     print() # это нужно для вывода в более "табличном" виде. В конце каждой строчки ставим перенос строки.

# Также перебирать элементы матрицы можно по индексам строки и столбца. Индекс строк - i, столбцов - j.
# Пример с использованием i'тых и j'тых элементов
# ROWS = 4
# COLS = 3
#
# matrix = [
#     [1, 2, 3],
#     [3, 4, 3],
#     [5, 6, 3],
#     [15, 16, 3],
# ]
#
# for i in range(ROWS):
#     for j in range(COLS):
#         print(matrix[i][j], end=" ")
#     print()



"""Написать цикл, считающий натуральные числа, пока их сумма не превысит 500"""
# s = 0
# n = 1
#
# while s < 500:
#     s += n
#     n += 1
# else:
#     print(
#         f'''Цель достигнута!
# Сумма равна: {s}
# Количество чисел: {n - 1}'''
#     )




"""Вывод ключей по значению"""
# d1ct = {'a': 1, 'b': 2, 'c': 3}
# key = [k for k, v in d1ct.items() if v == 2][0]
# print(key)

"""Когда использовать цикл while, когда for?"""
# Выбор типа цикла зависит от конкретной задачи и контекста.

# -------------- Использование while -------------
# 1. Неизвестное количество итераций. Если кол-во итераций неизвестно и зависит от условий, которые могут изменяться в
# процессе выполнения программы. Например, если мы ждём от пользователя ввод `exit`
# user_input = ""
# while user_input.lower() != 'exit':
#     user_input = input(': ')
# else:
#     print('Конец!')

# 2. Условия выхода. Если нужно контролировать выполнение цикла на основе сложных условий, которые могут изменяться в процессе выполнения.
# 3. Бесконечные циклы. Если нужен бесконечный цикл, выполняемый до тех пор, пока не будет выполнено определённое условие.
# while True:
#     if условие_выхода:
#         break

# -------------- Использование for -------------
# 1. Известное количество итераций. Если мы знаем, сколько раз хотим выполнить цикл.
# for i in range(5):
#     print(i)

# 2. Итерация по коллекциям. Идеально подходит для итерации по спискам, кортежам, множествам и словарям.
# fruits = ['яблоко', 'банан', 'вишня']
# for fruit in fruits:
#     print(fruit)

# 3. Читаемость кода. Делает код более читаемым и понятным (особенно при работе с коллекциями).

# --------------- Итог --------------
# while - количество итераций заранее неизвестно или зависит от изменяемых условий
# for - перебор по коллекциям и в случае заранее известного количества итераций.




"""Вывести название месяца"""
# num = int(input())
#
# season = (
#     'Весна' if num in [3, 4, 5] else
#     'Лето' if num in [6, 7, 8] else
#     'Осень' if num in [9, 10, 11] else
#     'Зима' if num in [12, 1, 2] else
#     'Некорректный месяц'
# )
#
# print(season)

# # Альтернативное решение
# month = int(input())
#
# if month in [3, 4, 5]:
#     print("Весна")
# elif month in [6, 7, 8]:
#     print("Лето")
# elif month in [9, 10, 11]:
#     print("Осень")
# elif month in [12, 1, 2]:
#     print("Зима")



"""Определить четверть точки по координатам"""
# # Решение ИИ
# dot_x = 30
# dot_y = -2
#
# quadrants = {
#     (True, True): 'I',
#     (False, True): 'II',
#     (False, False): 'III',
#     (True, False): 'IV'
# }
#
# print(quadrants[(dot_x > 0, dot_y > 0)])

# # Моё решение
# dot_x = 30
# dot_y = -2
#
# if dot_x > 0 and dot_y > 0:
#     print('I')
# elif dot_x < 0 and dot_y > 0:
#     print('II')
# elif dot_x < 0 and dot_y < 0:
#     print('III')
# elif dot_x > 0 and dot_y < 0:
#     print('IV')


"""Определить, что первый символ числа - чётный"""
# n = 2239324897482348
# str_n = str(n)
#
# print(True if int(str_n[0]) % 2 == 0 else False)

"""Определить вхождение элемента"""
# print('5' in str(123456789))

"""Создать словарь, буква алфавита - ключ, цифра - значение"""
# lst = [chr(i) for i in range(ord('a'), ord('z') + 1)]
# count = 1
# result = {}
#
# for letter in lst:
#     result[letter] = count
#     count += 1
#
# print(result)


"""Методы словарей"""
# Словари - это ИЗМЕНЯЕМЫЕ коллекции, которые хранят пары "ключ-значение".
# d = {'a': 1, 'b': 2}

# 1. fromkeys(iterable, value=None) - создаёт новый словарь с ключами из `iterable` и значением `value` (по умолчанию None)
# keys = ['a', 'b', 'c']
# d = dict.fromkeys(keys, 0)
# print(d) # {'a': 0, 'b': 0, 'c': 0}

# 2. clear() - удаляет все элементы из словаря
# d.clear()
# print(d)

# 3. copy() - возвращает поверхностную копию словаря
# d_copy = d.copy()
# print(d_copy)

# 4. get(key, default=None) - возвращает значение по ключу `key`. Если ключ не найден, возвращает default
# print(d.get('a', 'элемент не найден'))

# 5. items() - возвращает представление всех пар 'ключ-значение' в виде списка кортежей.
# print(d.items()) # dict_items([('a', 1), ('b', 2)])

# 6. keys() - возвращает предствление всех ключей в словаре.
# print(d.keys()) # dict_keys(['a', 'b'])

# 7. values() - возвращает представление всех значений в словаре
# print(d.values()) # dict_values([1, 2])

# 8. pop(key, default=None) - удаляет элемент с ключом `key` и возвращает его значение. Если ключ не найден, возвращает default
# value = d.pop('a')
# print(value) # 1 (значение a)
# print(d) # {'b': 2}

# 9. popitem() - удаляет и возвращает последнюю добавленную пару "ключ-значение" в виде кортежа.
# item = d.popitem()
# print(item) # ('b', 2)

# 10. setdefault(key, default=None) - возвращает значение по ключу `key`. Если ключ не существует, добавляет его со значением
# default и возвращает default
# d = {'a': 1}
# value = d.setdefault('b', 2)
# print(value)
# print(d)

# 11. update([other]) - обновляет словарь, добавляя пары 'ключ-значение' из другого словаря или итерируемого объекта.
# d.update({'b': 3, 'c': 4})
# print(d) # {'a': 1, 'b': 3, 'c': 4}


"""Методы кортежей"""
# Кортежи - это неизменяемые последовательности, которые могут содержать элементы разных типов.
# count(x) - возвращает количество вхождений элемента `x` в кортеже.
# t = (1, 2, 3, 4, 1, 1)
# print(t.count(1)) # 3

# index(x[, start[, end]]) - возвращает порядковый номер `x` в последовательности
# t = (1, 2, 3, 4, 1, 1)
# print(t.index(1))


"""Методы множества"""
# seq = {1, 2, 3, 5}
# seq1 = {4, 5, 6}
# union(other) - объединение, возвращает множество, состоящее из элементов set и other.
# print(seq.union(seq1))

# intersection(other) - пересечение, возвращает множество, состоящее из элементов, встречающихся и в set, и в other.
# print(seq.intersection(seq1)) # 5 (общий элемент)
#
# intersection_update(other) - обновляет текущее множество, оставляя только элементы, присутствующие в обоих множествах.
# print(seq.intersection(other))
#
# difference(other) - разность - возвращает множество элементов set, не встречающихся в OTHER.
# print(seq.difference(seq1)) # {1, 2, 3}
#
# difference_update() - обновляет текущее множество, удаляя элементы, присутствующие в другом множестве.
# print(seq.difference_update(seq1))
#
# symmetric_difference(other) - симметричная разность - возвращает множество, включающее все элементы исходных множеств, не принадлежащие обоим одновременно.
# print(seq.symmetric_difference(seq1)) # {1, 2, 3, 4, 6}
#
# symmetric_difference_update() - обновляет текущее множество, оставляя только элементы, присутствующие в одном из множеств, но не в обоих.

# add()
# remove() - вызывает ошибку KeyError при удалении, если элемент не существует
# discard() - НЕ ВЫЗЫВАЕТ ОШИБКУ при удалении, если элемент не существует
# pop() - удаляет и возвращает произвольный элемент из множества. Если множество пустое, ошибка KeyError
# clear() - удаляет все элементы из множества.
# update() - добавляет элементы из другого итерируемого объекта в текущее множество
# copy() - Создаёт и возвращает поверхностную копию множества
# issubset() - проверяет, является ли текущее множество подмножеством другого множества
# issuperset() - проверяет, является ли текущее множество надмножеством другого множества

"""Пример использования Split"""
# Разделить адресную строку на компоненты
# path = '/home/user/documents/file.txt'
#
# print(
#     path.split('/')
# )


"""Изменяемые и неизменяемые типы данных"""
# Неизменяемые типы:
# int, float, str, bool, tuple, bytes, frozensets

# Изменяемые типы:
# list, dict, set, bytearray

# # --------------- Пример неизменяемости данных -------------- # #
# my_string = 'Hello world'
# try:
#     my_string[0] = 'h'
# except TypeError as e:
#     print(f'Ошибка: {e}')
#
# my_string = 'h' + my_string[1:]
# print(my_string)


"""Типы данных в Python"""
# 1. None (NoneType) - отсутствие значения или пустота. Он используется для того, что переменная не содержит никакого значения.
# x = None
# if x is None:
#     print("x не имеет значения")

# 2. Complex - используется для представления комплексных чисел, имеющих действительную и мнимую части.
# Записываются в виде: a + bj, a - действительная часть, b - мнимая часть.
# a = 4 + 3j # 4 - действительное число, 3 - мнимое
# print(
#     type(a),
#     'Действительное число: ' + str(a.real),
#     'Мнимое число: ' + str(a.imag),
#     sep='\n'
# )

# 3. Byte Arrays - ИЗМЕНЯЕМАЯ последовательность байтов. Он используется для работы с бинарными данными, которые могут
# изменяться после создания. Это полезно, когда необходимо манипулировать данными на уровне байтов.
# b = bytearray([50, 100, 76])
# b[0] = 65 # Изменение первого элемента
# print(b)

# 4. Bytes - НЕИЗМЕНЯЕМАЯ последовательность байтов. Используется для хранения бинарных данных (изображения, аудио, текст в кодировке кроме UTF-8)
# b = bytes([50, 100, 76])
# print(b)

# 5. Tuples - НЕИЗМЕНЯЕМАЯ последовательность элементов. Используется для хранения коллекций объектов, не подразумевающихся к изменению.
# Кортежи могут содержать элементы разных типов и могут использоваться как ключи в словарях.
# Используют когда нужно сохранить несколько связанных по смыслу между собой объектов, и они не подразумеваются к изменению.
# t = (1, 2, 3)
# print(t[0])

# 6. Sets - ИЗМЕНЯЕМАЯ НЕУПОРЯДОЧЕННАЯ коллекция уникальных элементов.
# Используется для хранения уникальных значений и выполнения опреаций: объединение, пересечение и разность.
# s = {1, 2, 3, 2}
# print(s)

# 7. Frozen Sets - НЕИЗМЕНЯЕМАЯ версия set. Коллекция уникальных элементов, но не может быть изменён после создания.
# Это делает его подходящим для использования в качестве ключей в словарях.
# fs = frozenset([1, 2, 3, 2])
# print(fs)

# 8. Dictionaries - неупорядоченная коллекция пар "Ключ-значение". Используется для хранения данных, где каждый элемент
# имеет уникальный ключ, используемый для доступа к соответствующему значению. Полезны для хранения ассоциативных массивов и объектов.
# Ключ может быть объектом неизменяемых типов данных.
# d = {'name': 'Alice', 'age': 25}
# print(d['name']) # Alice

# 9. List - Список - упорядоченный набор объектов произвольного типа. Упорядоченная структура данных - каждый элемент списка имеет свой индекс.

"""Python: определение"""
# Неявная сильная динамическая типизация.
# Неявная - тип переменной НЕ указывается явно при её объявлении. Не указываем тип переменной при создании.
# x = 10 # не имеет явного типа, автоматически определяется как x

# Сильная - Python строго проверяет типы данных и не позволяет выполнять операции между несовместимыми типами
# без явного преобразования.

# Динамическая - Тип переменной может изменяться во время выполнения программы. Можно создать переменную с одним типом, а затем привсвоить другой.
# x = 10
# x = 'Hello'

"""Почему был переход с Python 2 на Python 3"""
# Python 3.0 разрабатывался с целью устранения фундаментальных изъянов в языке, уменьшения дублирующейся функциональности
# и устранения неэффективных реализаций в языке.


"""Плюсы и минусы Python"""
# # +++++++++++++++ Плюсы +++++++++++++++++ # #
# 1. Кроссплатформенность. Способность программы работать более чем на одной аппаратной платформе или в более чем одной операционной системе.
# 2. Многогранность применения: микроконтроллеры, алгоритмы машинного обучения, анализ данных, web, робототехника, IoT.
# 3. Обилие дополнительных библиотек. Богатая коллекция уже готовых решений неких задач с подробной документацией реализованного.
# 4. Дружелюбный синтаксис: высокая скорость написания программ и возможность лёгкой отладки


# # --------------- Недостатки -------------- # #
# 1. Доступность исходного кода
# 2. Низкая скорость. Интерпретируемые языки затрачивают время на преобразование в машинный код во время выполнения самой программы,
# в отличие от компилируемых, которые делают это до момента начала выполнения.
# 3. Неоптимальный расход ресурсов памяти. Python довольно гибко работает с типами данных, из-за этого его работа с памятью неоптимальна,
# и программы на Python потребляют больше ресурсов, чем могли бы.
# 4. Использование подхода с общесистемными зависимостями по умолчанию. Все модули устанавливаются в одно место на компьютере.
# То есть, все зависимости устанавливаются в папку с интерпретатором. Любой проект, использующий интерпретатор, исп. устан. в нём модули.

# # --------------- Кто использует Python -------------- # #
# Google, Yandex, Facebook, Instagram, Youtube, Dropbox, Reddit, Spotify, Mozilla, игра (Civilization IV, Battlefield).


"""Что такое синтаксис ЯП"""
# Синтаксис ЯП - это набор предписанных правил, на основе которых строится программа.
# Как пример, строго определённый набор ключевых слов, описывающих команды для компьютера. В этих словах важен каждый символ:
# любое несоответствие или неоднозначность в коде приводит к ошибке. Структура кода сопоставима с логичностью повествования:
# сначало - посадили семя, затем - выросло дерево.


"""Что такое транслятор?"""
# Транслятор - программа, выполняющая преобразование программы, написанной на одном из высокоуровневых ЯП, в программу,
# состоящую из машинных команд. Язык входной программы назвается исходным языком, а сама программа - исходным кодом.
# Выходной язык называется целевым языком или объектным кодом.

# Проще говоря, трансляторы - переводчики программ с языков высокого уровня на машинный язык, с которым будет работать процессор.
# Текст программы (высокоуровневый ЯП) -> Транслятор (программа-переводчик) -> Машинный код (Низкоуровневый язык).


"""Что такое интерпретатор?"""
# Интерпретатор - разновидность транслятора - напрямую выполняет текст код без его предварительного преобразования в машинный код.
# Программа всегда остаётся на исходном языке и не может быть запущена на выполнение без использования интерпретатора.
# (!) Каждая строка исходного кода переводится в машинный код за один проход интерпретатора.
# (!) В данном случае программа в машинном коде существует только во время интерпретации и не сохраняется в виде отдельного файла.

# # +++++++++++++++ Достоинства +++++++++++++++++ # #
# 1. Кроссплатформенность. Способность программы работать более чем на одной аппаратной платформе или в более чем одной операционной системе.


# # --------------- Недостатки -------------- # #
# 1. Доступность исходного кода
# 2. Низкая скорость. При каждом запуске требуется интерпретация кода, что занимает время.

# # --------------- Примеры -------------- # #
# 1. CPython (Python Interpreter).
# 2. CLisp.
# 3. JavaScript Engines (V8).
# 4. PHP Interpreter, Ruby MRI


"""Что такое компилятор?"""
# Компилятор выполняет преобразование (компиляцию) программы, написанной на языке высокого уровня (исходный ЯП) - в машинный код.
# Следом этот код записывается в исполняемый файл (например, exe.), который может быть запущен как и любая другая программа на компьютере.
# Компиляция выполняется единожды, а исполняемый файл (программа) может использоваться в cистеме, под которую была выполнена компиляция, сколько угодно раз.
# Однако, если потребуется внести изменения в исходный код, это потребует повторной компиляции, а процесс компиляции достаточно медленный.

# # +++++++++++++++ Достоинства +++++++++++++++++ # #
# 1. Скорость выполнения программы


# # --------------- Недостатки -------------- # #
# 1. Платформозависимость. Зависит от программной и аппаратной платформы компьютера, на котором производится компиляция программы.

# # --------------- Примеры -------------- # #
# 1. GCC (GNU Compiler Collection). Набор компиляторов для различных ЯП, включая C, C++, Fortran.
# 2. CLang.
# 3. Javac (Java Compiler).
# 4. PHP Interpreter, Ruby MRI


"""Что такое машинный код?"""
# МК - это набор команд, непосредственно выполняемых центральным процессором компьютера. МК - самое низкоуровневое представление
# компьютерной программы, и в то же время его можно рассматривать как упрощённый и аппаратно-зависимый (то есть зависимый от конкретной
# аппаратной части) язык.


"""Что такое ЯП?"""
# ЯП - строго определённый набор правил, благодаря которому возможно взаимодействие человека с компьютером.
# ЯП - инструмент, благодаря которому человек может управлять компьютером.
# Иногда важна скорость работы программы, поэтому мы не тратим время на "перевод", иной раз важнее скорость написания кода.

"""Классификация ЯП"""
# 1. Низкоуровневые (Assembler, CIL). Созданы для удовлетворения нужд конкретной компьютерной архитектуры и учитывают требования железа,
# скорость их работы выше, чем верхнеуровневых. Применяются редко и для узкоспециализированных задач:
# Разработка ОС, Криптография, Компиляторы, Интерпретаторы, Драйверы
#
# 2. Высокоуровневые (Python, C++, Kotlin, C#, Java...). Созданы с расчётом на то, что их должны понимать люди и с ними
# должно быть удобно работать. Они платформонезависимы (программистам не нужно знать, на каком именно оборудовании будет
# запускаться программа. Скорость выполнения программы компенсируется скоростью её написания.
# За удобство пользования приходится платить памятью. Программы высокоуровневых ЯП требуют для своей работы и хранения
# значительно больше памяти, чем программы, написанные на низкоуровневых языках.


"""Особенность операций целочисленного деления и нахождение остатка от деления для неположительных чисел"""
# Формула: a = b*q+r
# a = 5
# b = 2
# q = a // b # q = 2
# r = a % b

# a = 5
# b = -2
# q = a // b # в данном случае q = -3
# r = a % b # а остаток r = -1


"""Тернарный оператор"""
# a = 10
# b = 29
#
# max_value = a if a > b else b
# print(max_value)

# x = 5
# result = "чётное" if x % 2 == 0 else "нечётное"
# print(result)

# x = 15
# result = "положительное" if x > 0 else "ноль" if x == 0 else "отрицательное"


