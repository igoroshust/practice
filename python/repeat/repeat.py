seq = {1, 2, 3, 5}
seq1 = {4, 5, 6}

print(
    seq.union(seq1),
    seq.intersection(seq1),
    seq.difference(seq1),
    seq.symmetric_difference(seq1),
    sep='\n'
)

seq.pop()
print(seq)


"""Методы множества"""
# seq = {1, 2, 3, 5}
# seq1 = {4, 5, 6}
# union(other) - объединение, возвращает множество, состоящее из элементов set и other.
# print(seq.union(seq1))

# intersection(other) - пересечение, возвращает множество, состоящее из элементов, встречающихся и в set, и в other.
# print(seq.intersection(seq1)) # 5 (общий элемент)
#
# intersection_update(other) - обновляет текущее множество, оставляя только элементы, присутствующие в обоих множествах.
# print(seq.intersection(other))
#
# difference(other) - разность - возвращает множество элементов set, не встречающихся в OTHER.
# print(seq.difference(seq1)) # {1, 2, 3}
#
# difference_update() - обновляет текущее множество, удаляя элементы, присутствующие в другом множестве.
# print(seq.difference_update(seq1))
#
# symmetric_difference(other) - симметричная разность - возвращает множество, включающее все элементы исходных множеств, не принадлежащие обоим одновременно.
# print(seq.symmetric_difference(seq1)) # {1, 2, 3, 4, 6}
#
# symmetric_difference_update() - обновляет текущее множество, оставляя только элементы, присутствующие в одном из множеств, но не в обоих.

# add()
# remove() - вызывает ошибку KeyError при удалении, если элемент не существует
# discard() - НЕ ВЫЗЫВАЕТ ОШИБКУ при удалении, если элемент не существует
# pop() - удаляет и возвращает произвольный элемент из множества. Если множество пустое, ошибка KeyError
# clear() - удаляет все элементы из множества.
# update() - добавляет элементы из другого итерируемого объекта в текущее множество
# copy() - Создаёт и возвращает поверхностную копию множества
# issubset() - проверяет, является ли текущее множество подмножеством другого множества
# issuperset() - проверяет, является ли текущее множество надмножеством другого множества

"""Пример использования Split"""
# Разделить адресную строку на компоненты
# path = '/home/user/documents/file.txt'
#
# print(
#     path.split('/')
# )


"""Изменяемые и неизменяемые типы данных"""
# Неизменяемые типы:
# int, float, str, bool, tuple, bytes, frozensets

# Изменяемые типы:
# list, dict, set, bytearray

# # --------------- Пример неизменяемости данных -------------- # #
# my_string = 'Hello world'
# try:
#     my_string[0] = 'h'
# except TypeError as e:
#     print(f'Ошибка: {e}')
#
# my_string = 'h' + my_string[1:]
# print(my_string)


"""Типы данных в Python"""
# 1. None (NoneType) - отсутствие значения или пустота. Он используется для того, что переменная не содержит никакого значения.
# x = None
# if x is None:
#     print("x не имеет значения")

# 2. Complex - используется для представления комплексных чисел, имеющих действительную и мнимую части.
# Записываются в виде: a + bj, a - действительная часть, b - мнимая часть.
# a = 4 + 3j # 4 - действительное число, 3 - мнимое
# print(
#     type(a),
#     'Действительное число: ' + str(a.real),
#     'Мнимое число: ' + str(a.imag),
#     sep='\n'
# )

# 3. Byte Arrays - ИЗМЕНЯЕМАЯ последовательность байтов. Он используется для работы с бинарными данными, которые могут
# изменяться после создания. Это полезно, когда необходимо манипулировать данными на уровне байтов.
# b = bytearray([50, 100, 76])
# b[0] = 65 # Изменение первого элемента
# print(b)

# 4. Bytes - НЕИЗМЕНЯЕМАЯ последовательность байтов. Используется для хранения бинарных данных (изображения, аудио, текст в кодировке кроме UTF-8)
# b = bytes([50, 100, 76])
# print(b)

# 5. Tuples - НЕИЗМЕНЯЕМАЯ последовательность элементов. Используется для хранения коллекций объектов, не подразумевающихся к изменению.
# Кортежи могут содержать элементы разных типов и могут использоваться как ключи в словарях.
# Используют когда нужно сохранить несколько связанных по смыслу между собой объектов, и они не подразумеваются к изменению.
# t = (1, 2, 3)
# print(t[0])

# 6. Sets - НЕУПОРЯДОЧЕННАЯ ИЗМЕНЯЕМАЯ коллекция уникальных элементов.
# Используется для хранения уникальных значений и выполнения опреаций: объединение, пересечение и разность.
# s = {1, 2, 3, 2}
# print(s)

# 7. Frozen Sets - НЕИЗМЕНЯЕМАЯ версия set. Коллекция уникальных элементов, но не может быть изменён после создания.
# Это делает его подходящим для использования в качестве ключей в словарях.
# fs = frozenset([1, 2, 3, 2])
# print(fs)

# 8. Dictionaries - неупорядоченная коллекция пар "Ключ-значение". Используется для хранения данных, где каждый элемент
# имеет уникальный ключ, используемый для доступа к соответствующему значению. Полезны для хранения ассоциативных массивов и объектов.
# Ключ может быть объектом неизменяемых типов данных.
# d = {'name': 'Alice', 'age': 25}
# print(d['name']) # Alice

# 9. List - Список - упорядоченный набор объектов произвольного типа. Упорядоченная структура данных - каждый элемент списка имеет свой индекс.

"""Python: определение"""
# Неявная сильная динамическая типизация.
# Неявная - тип переменной не указывается явно при её объявлении. Не указываем тип переменной при создании.
# x = 10 # не имеет явного типа, автоматически определяется как x

# Сильная - Python строго проверяет типы данных и не позволяет выполнять операции между несовместимыми типами
# без явного преобразования.

# Динамическая - Тип переменной может изменяться во время выполнения программы. Можно создать переменную с одним типом, а затем привсвоить другой.
# x = 10
# x = 'Hello'

"""Почему был переход с Python 2 на Python 3"""
# Python 3.0 разрабатывался с целью устранения фундаментальных изъянов в языке, уменьшения дублирующейся функциональности
# и устранения неэффективных реализаций в языке.


"""Плюсы и минусы Python"""
# # +++++++++++++++ Плюсы +++++++++++++++++ # #
# 1. Кроссплатформенность. Способность программы работать более чем на одной аппаратной платформе или в более чем одной операционной системе.
# 2. Многогранность применения: микроконтроллеры, алгоритмы машинного обучения, анализ данных, web, робототехника, IoT.
# 3. Обилие дополнительных библиотек. Богатая коллекция уже готовых решений неких задач с подробной документацией реализованного.
# 4. Дружелюбный синтаксис: высокая скорость написания программ и возможность лёгкой отладки


# # --------------- Недостатки -------------- # #
# 1. Доступность исходного кода
# 2. Низкая скорость. Интерпретируемые языки затрачивают время на преобразование в машинный код во время выполнения самой программы,
# в отличие от компилируемых, которые делают это до момента начала выполнения.
# 3. Неоптимальный расход ресурсов памяти. Python довольно гибко работает с типами данных, из-за этого его работа с памятью неоптимальна,
# и программы на Python потребляют больше ресурсов, чем могли бы.
# 4. Использование подхода с общесистемными зависимостями по умолчанию. Все модули устанавливаются в одно место на компьютере.
# То есть, все зависимости устанавливаются в папку с интерпретатором. Любой проект, использующий интерпретатор, исп. устан. в нём модули.

# # --------------- Кто использует Python -------------- # #
# Google, Yandex, Facebook, Instagram, Youtube, Dropbox, Reddit, Spotify, Mozilla, игра (Civilization IV, Battlefield).


"""Что такое синтаксис ЯП"""
# Синтаксис ЯП - это набор предписанных правил, на основе которых строится программа.
# Как пример, строго определённый набор ключевых слов, описывающих команды для компьютера. В этих словах важен каждый символ:
# любое несоответствие или неоднозначность в коде приводит к ошибке. Структура кода сопоставима с логичностью повествования:
# сначало - посадили семя, затем - выросло дерево.


"""Что такое транслятор?"""
# Транслятор - программа, выполняющая преобразование программы, написанной на одном из высокоуровневых ЯП, в программу,
# состоящую из машинных команд. Язык входной программы назвается исходным языком, а сама программа - исходным кодом.
# Выходной язык называется целевым языком или объектным кодом.

# Проще говоря, трансляторы - переводчики программ с языков высокого уровня на машинный язык, с которым будет работать процессор.
# Текст программы (высокоуровневый ЯП) -> Транслятор (программа-переводчик) -> Машинный код (Низкоуровневый язык).


"""Что такое интерпретатор?"""
# Интерпретатор - разновидность транслятора - напрямую выполняет текст код без его предварительного преобразования в машинный код.
# Программа всегда остаётся на исходном языке и не может быть запущена на выполнение без использования интерпретатора.
# (!) Каждая строка исходного кода переводится в машинный код за один проход интерпретатора.
# (!) В данном случае программа в машинном коде существует только во время интерпретации и не сохраняется в виде отдельного файла.

# # +++++++++++++++ Достоинства +++++++++++++++++ # #
# 1. Кроссплатформенность. Способность программы работать более чем на одной аппаратной платформе или в более чем одной операционной системе.


# # --------------- Недостатки -------------- # #
# 1. Доступность исходного кода
# 2. Низкая скорость. При каждом запуске требуется интерпретация кода, что занимает время.

# # --------------- Примеры -------------- # #
# 1. CPython (Python Interpreter).
# 2. CLisp.
# 3. JavaScript Engines (V8).
# 4. PHP Interpreter, Ruby MRI


"""Что такое компилятор?"""
# Компилятор выполняет преобразование (компиляцию) программы, написанной на языке высокого уровня (исходный ЯП) - в машинный код.
# Следом этот код записывается в исполняемый файл (например, exe.), который может быть запущен как и любая другая программа на компьютере.
# Компиляция выполняется единожды, а исполняемый файл (программа) может использоваться в cистеме, под которую была выполнена компиляция, сколько угодно раз.
# Однако, если потребуется внести изменения в исходный код, это потребует повторной компиляции, а процесс компиляции достаточно медленный.

# # +++++++++++++++ Достоинства +++++++++++++++++ # #
# 1. Скорость выполнения программы


# # --------------- Недостатки -------------- # #
# 1. Платформозависимость. Зависит от программной и аппаратной платформы компьютера, на котором производится компиляция программы.

# # --------------- Примеры -------------- # #
# 1. GCC (GNU Compiler Collection). Набор компиляторов для различных ЯП, включая C, C++, Fortran.
# 2. CLang.
# 3. Javac (Java Compiler).
# 4. PHP Interpreter, Ruby MRI


"""Что такое машинный код?"""
# МК - это набор команд, непосредственно выполняемых центральным процессором компьютера. МК - самое низкоуровневое представление
# компьютерной программы, и в то же время его можно рассматривать как упрощённый и аппаратно-зависимый (то есть зависимый от конкретной
# аппаратной части) язык.


"""Что такое ЯП?"""
# ЯП - строго определённый набор правил, благодаря которому возможно взаимодействие человека с компьютером.
# ЯП - инструмент, благодаря которому человек может управлять компьютером.
# Иногда важна скорость работы программы, поэтому мы не тратим время на "перевод", иной раз важнее скорость написания кода.

"""Классификация ЯП"""
# 1. Низкоуровневые (Assembler, CIL). Созданы для удовлетворения нужд конкретной компьютерной архитектуры и учитывают требования железа,
# скорость их работы выше, чем верхнеуровневых. Применяются редко и для узкоспециализированных задач:
# Разработка ОС, Криптография, Компиляторы, Интерпретаторы, Драйверы
#
# 2. Высокоуровневые (Python, C++, Kotlin, C#, Java...). Созданы с расчётом на то, что их должны понимать люди и с ними
# должно быть удобно работать. Они платформонезависимы (программистам не нужно знать, на каком именно оборудовании будет
# запускаться программа. Скорость выполнения программы компенсируется скоростью её написания.
# За удобство пользования приходится платить памятью. Программы высокоуровневых ЯП требуют для своей работы и хранения
# значительно больше памяти, чем программы, написанные на низкоуровневых языках.


"""Особенность операций целочисленного деления и нахождение остатка от деления для неположительных чисел"""
# Формула: a = b*q+r
# a = 5
# b = 2
# q = a // b # q = 2
# r = a % b


a = 5
b = -2
q = a // b # в данном случае q = -3
r = a % b # а остаток r = -1





